<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java编程思想——第七章(复用类)</title>
      <link href="/2020/04/09/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E7%AB%A0(%E5%A4%8D%E7%94%A8%E7%B1%BB)/"/>
      <url>/2020/04/09/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E7%AB%A0(%E5%A4%8D%E7%94%A8%E7%B1%BB)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第七章(复用类)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>复用代码是Java众多引人注目的功能之一。但想要成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的的，它还必须能够做更多的事情。</p></blockquote><h1 id="组合语法"><a href="#组合语法" class="headerlink" title="组合语法"></a>组合语法</h1><p>有一个方法很特殊：<strong>toString()</strong>。每一个<strong>非基本类型的对象</strong>都会有一个toString()方法，当编译器需要一个String而你却只有一个对象时，这个方法便会被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    Engine() &#123;</span><br><span class="line">        println(<span class="string">"Engine()"</span>);</span><br><span class="line">        s = <span class="string">"Constructed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlane</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Engine N1 = <span class="keyword">new</span> AirPlane();</span><br><span class="line">System.out.println(N1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//:output:Constructed</span></span><br></pre></td></tr></table></figure><h1 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h1><p><strong>继承是所有OOP语言不可缺少的组成部分</strong>。当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承， 否则就是在隐式地从Java的标准根类<strong>Object</strong>进行继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cleanser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Detergent</span> <span class="keyword">extends</span> <span class="title">Cleanser</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使是一个程序中含有多个类，也只有<strong>命令行所调用的那个类的main()方法</strong>会被调用。因此，在此例中，如果命令行是java Detergent，那么Detergent.main()将会被调用，而即使Cleanser不是一个public类，如果命令行是java Cleanser，那么Cleanser.main()仍然会被调用。<br><strong>即使一个类只具有包访问权限，其public main()仍然是可访问的。</strong><br>继承的一般规则是所有的<strong>数据成员都指定为private</strong>，而所有的<strong>方法指定为public</strong>。</p><pre><code>super.fiction()即调用基类版本的fiction()方法。</code></pre><h2 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Art</span></span>&#123;</span><br><span class="line">    Art()&#123; print(<span class="string">"Art constructor"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Art</span></span>&#123;</span><br><span class="line">    Drawing()&#123; print(<span class="string">"Drawing constructor"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cartoon</span> <span class="keyword">extends</span> <span class="title">Drawing</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cartoon</span><span class="params">()</span></span>&#123;print(<span class="string">"Cartoon constructor"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Cartoon x = <span class="keyword">new</span> Cartoon();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Art constructor</span></span><br><span class="line"><span class="comment">Drawing constructor</span></span><br><span class="line"><span class="comment">Cartoon constructor</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p><strong>构建过程是从基类“向外”扩散的，所以基类在导出类构造器可以访问它之前，就已经完成了初始化。</strong><br>即便不为Cartoon()创建构造器，编译器也会为你合成一个默认的构造器，该构造器将调用基类的构造器。</p><p><strong>带参数的构造器</strong><br>想调用一个带参数的基类构造器，就必须使用关键字<strong>super显式</strong>地编写调用基类构造器的语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    Game(<span class="keyword">int</span> i)&#123;</span><br><span class="line">        print(<span class="string">"Game constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoardGame</span> <span class="keyword">extends</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    BoardGame(<span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">super</span>(i);</span><br><span class="line">        print(<span class="string">"BoardGame constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">BoardGame</span></span>&#123;</span><br><span class="line">    Chess()&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">11</span>);</span><br><span class="line">        print(<span class="string">"Chess constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Chess x = <span class="keyword">new</span> Chess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：如果不在BoardGame()中调用基类构造器，编译器将“抱怨”无法找到符合Game()形式的构造器。同时，调用基类构造器必须是导出类构造器中要做的第一件事，即<strong>第一条完整语句</strong>。</p></blockquote><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>代理为<strong>继承与组合之间的中庸之道</strong>，Java并没有提供对它的直接支持。<br>因为它既将一个成员对象置于所要构造的类中（组合），同时也在新类中暴露了该成员对象的所有方法（继承）。</p><h1 id="结合使用组合和继承"><a href="#结合使用组合和继承" class="headerlink" title="结合使用组合和继承"></a>结合使用组合和继承</h1><p>同时使用组合和继承是很常见的事。</p><h2 id="确保正确清理"><a href="#确保正确清理" class="headerlink" title="确保正确清理"></a>确保正确清理</h2><blockquote><p>12章会详细说明try和finally两个关键字。其中关键字try表示，下面的块是所谓的保护区（guarde region），这意味着它需要被特殊处理。其中的一项特殊处理就是无论try块是如何退出的，保护区后的finally子句中的代码总是要被执行的。</p></blockquote><p>由于垃圾回收器可能以任何它想要的顺序回收对象，<strong>最好除了内存以外，不依赖垃圾回收器去做任何事</strong>。需要进行清理，最好是编写自己的清理方法，<strong>但不要使用finalize()</strong>。</p><h2 id="名称屏蔽"><a href="#名称屏蔽" class="headerlink" title="名称屏蔽"></a>名称屏蔽</h2><p>在Java中可以对继承类引入重载方法（相对基类而言），但是<strong>在C++中若要完成这项工作则需要屏蔽基类方法</strong>。<br>Java SE5中增加了<font><strong>@Override</strong>注解以<strong>确保覆盖</strong>，而非重载。它虽不是关键字，但是可以把它当做关键字使用。<br><code>@Override void f(){//....}</code></p><h1 id="在组合与继承之间选择"><a href="#在组合与继承之间选择" class="headerlink" title="在组合与继承之间选择"></a>在组合与继承之间选择</h1><p>组合：显式地在新的类中放置子对象，<strong>复用具体实现，无法看见嵌入对象的接口。</strong></p><ul><li>“汽车”（新类）have  “发动机” “轮胎” “车门”（基类）</li></ul><p>继承：隐式地在新的类中放置子对象，<strong>复用接口</strong>。</p><ul><li>“汽车”（继承类）is  “交通工具”（基类）</li></ul><h1 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h1><p>将继承类对象引用转换为基类对象引用的动作，称之为向上转型。<br><strong>需慎用继承这一技术，一个最清晰的判断办法就是问自己是否需要从新类向基类进行向上转型</strong>。</p><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><h2 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h2><p>既是static优势final的域叫做<strong>编译期常量</strong>，需要用大写表示，并使用下划线分隔各个单词。<br>final表示数据无法修改，<strong>若数据是基本类型，便无法修改，若数据是引用，则该引用所指向的对象恒定不变，而指向对象的内容可以更改</strong>。</p><p><strong>空白final</strong><br>所谓“空白final”是指被声明为final但又未给定初值的域。<br><strong>必须在域的定义出或者每个构造器中用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在</strong>。</p><h2 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h2><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味着<strong>无法更改参数引用所指向的对象</strong>。</p><h2 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h2><p>使用final方法有<strong>两个原因</strong></p><ol><li>把方法锁定，以防止任何继承类修改它的含义，确保在继承中是方法行为保持不变，并且不会被覆盖。</li><li>效率原因，在Java的早期实现中，将方法指明为final，则编译器将会针对该方法的所有调用转为内嵌调用。于是编译器在调用这个方法时，会谨慎判断，跳过插入程序代码这种正常方式而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值），同时使用方法体中的实际代码副本来代替方法调用，从而消除方法调用的开销。如果一个方法很大，程序代码便会很大，因而看不到内嵌带来的任何性能提高，因为，所带来的的性能提高会因为花费于方法内的时间量而被缩减。</li></ol><p>到了Java SE5/6时，应该<strong>让编译器和JVM去处理效率问题</strong>，而只有在想要<strong>明确禁止覆盖</strong>时，才应该将方法设置为final的。</p><h2 id="final和private关键字"><a href="#final和private关键字" class="headerlink" title="final和private关键字"></a>final和private关键字</h2><p>private方法<strong>隐式地指定为final</strong>，可以对private方法添加final修饰词，但是并不能增加任何额外的意义。<br>如果想要“覆盖”一个private方法， 似乎是奏效的，因为基类中的private方法在继承类中不可见也不可用，<strong>于是所谓的“覆盖”便是新建了一个与之同名的方法。</strong></p><h2 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h2><p>将某个类整体定义为final，便表明了你<strong>不打算继承该类，不希望它有子类</strong>，同时该类中的所有方法都隐式地指定为final的，也可对这些方法添加final修饰词但是同样不存在任何额外的意义。</p><blockquote><p><strong>Java中的final类</strong><br>    - 基本类型的包装类<br>    - 字符串：String、StringBuilder、StringBuffer<br>    - 数字：Math、StrictMath<br>    - 系统：System、Class</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(Python)凯撒密码exe</title>
      <link href="/2020/04/06/(Python)%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81exe/"/>
      <url>/2020/04/06/(Python)%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81exe/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于QtDesigner<strong>凯撒密码</strong>窗体程序的简易实现</p></blockquote><a id="more"></a><hr><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在密码学中，凯撒密码（Caesar cipher），或称凯撒加密、凯撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期凯撒的名字命名的，据称当年凯撒曾用此方法与其将军们进行联系。</p><p>凯撒密码的加密、解密方法还能够通过同余的数学方法进行计算。<br><strong>首先将字母用数字代替，A=0，B=1，…，Z=25。此时偏移量为n的加密方法即为：</strong><br>$$ E_n(x) = (x+n) mod26 $$<br><strong>解密就是：</strong><br>$$ D_n(x) = (x-n) mod26 $$</p><hr><h1 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h1><p>用户输入一段偏移量（Offset），<strong>其范围应该在0~65535内</strong>。然后可以手动输入一段内容或是从文本文件中导入内容，其内容可以是任何数据。随后用户根据偏移量对其进行加密或者解密。</p><ol><li>如果输入的偏移量不符合规范，则会跳出出错提示框。</li><li>其中英文字母的加解密原理为凯撒密码，即将a-z（大写同理）编号x为0-25。<br> 1) 加密：得到E(x) = (x+Offset)mod26,将E(x)根据编号转换成字母。<br> 2) 解密：得到E(x) = (x-Offset)mod26,将E(x)根据编号转换成字母。</li><li>其中的汉字字符加解密为 M(x) = (x+Offset)mod1000，其中x为汉字的ascii码，再由得到的M(x)依据ascii码表转换成相应的汉字字符。</li><li>其余字符均会不变。</li><li>加解密得到的数据可以导出到本地文件中。</li></ol><hr><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>使用Python语言实现窗体程序可以使用自带的<strong>tkinter库</strong>或是使用<strong>PyQt</strong><br>这里我使用了PyQt工具包，它是Python和Qt库的成功融合，再搭配QtDesigner，能够以可视化的方式轻松生成PyQt代码</p><h2 id="主要算法代码"><a href="#主要算法代码" class="headerlink" title="主要算法代码"></a>主要算法代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">index</span><span class="params">(QtWidgets.QMainWindow, Ui_CipherWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(index, self).__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">JudgeInvalid</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 提示框样式</span></span><br><span class="line">        msgBox = QtWidgets.QMessageBox()</span><br><span class="line">        msgBox.setWindowTitle(<span class="string">u'提示'</span>)</span><br><span class="line">        msgBox.setText(<span class="string">u'输入格式不规范！  '</span>)</span><br><span class="line">        msgBox.setStyleSheet(<span class="string">'padding:10px 10px 0px 0;\</span></span><br><span class="line"><span class="string">               color: rgb(88, 38, 48);\</span></span><br><span class="line"><span class="string">               background-color: rgb(242, 97, 87);\</span></span><br><span class="line"><span class="string">               font-weight:bold;'</span>)</span><br><span class="line">        msgBox.setWindowIcon(QtGui.QIcon(<span class="string">':/message.png'</span>))</span><br><span class="line">        msgBox.addButton(QtWidgets.QMessageBox.Ok)</span><br><span class="line">        msgBox.button(QtWidgets.QMessageBox.Ok).hide()</span><br><span class="line"></span><br><span class="line">        OffsetText = self.OffsetText.toPlainText()</span><br><span class="line">        InvalidSymbol = re.findall(<span class="string">r"[^0-9]"</span>, OffsetText)</span><br><span class="line">        <span class="keyword">if</span> len(InvalidSymbol) != <span class="number">0</span>:</span><br><span class="line">            msgBox.exec_()</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DocumentBtn_Click</span><span class="params">(self)</span>:</span></span><br><span class="line">        OpenFile = QFileDialog.getOpenFileName(self, <span class="string">'打开'</span>, <span class="string">"./"</span>, <span class="string">"Txt files(*.txt)"</span>)</span><br><span class="line">        <span class="keyword">if</span> OpenFile[<span class="number">0</span>] != <span class="string">''</span>:</span><br><span class="line">            f = open(OpenFile[<span class="number">0</span>], <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line">            data = f.read(<span class="number">1024</span>)</span><br><span class="line">            self.InputContenText.setPlainText(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ExportDocBtn_Click</span><span class="params">(self)</span>:</span></span><br><span class="line">        SaveFile = QFileDialog.getSaveFileName(self, <span class="string">'保存'</span>, <span class="string">"./"</span>, <span class="string">"Txt files(*.txt)"</span>)</span><br><span class="line">        <span class="keyword">if</span> SaveFile[<span class="number">0</span>] != <span class="string">''</span>:</span><br><span class="line">            f = open(SaveFile[<span class="number">0</span>], <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line">            ResultText = self.OutputContentText.toPlainText()</span><br><span class="line">            f.write(ResultText)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EncryptBtn_Click</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.JudgeInvalid() == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        Content = self.InputContenText.toPlainText()</span><br><span class="line">        OffsetText = self.OffsetText.toPlainText()</span><br><span class="line">        Offset = int(OffsetText)</span><br><span class="line">        Result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> Content:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="string">'a'</span> <span class="keyword">and</span> i &lt;= <span class="string">'z'</span>:</span><br><span class="line">                Result += chr(ord(<span class="string">'a'</span>) + (ord(i)-ord(<span class="string">'a'</span>) + Offset) % <span class="number">26</span>)</span><br><span class="line">            <span class="keyword">elif</span> i &gt;= <span class="string">'A'</span> <span class="keyword">and</span> i &lt;= <span class="string">'Z'</span>:</span><br><span class="line">                Result += chr(ord(<span class="string">'A'</span>) + (ord(i) - ord(<span class="string">'A'</span>) + Offset) % <span class="number">26</span>)</span><br><span class="line">            <span class="keyword">elif</span> i &gt;= <span class="string">'\u4e00'</span> <span class="keyword">and</span> i &lt;=  <span class="string">'\u9fff'</span>:</span><br><span class="line">                Result += chr(ord(i) + Offset % <span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Result += i</span><br><span class="line">        self.OutputContentText.setPlainText(Result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DecryptBtn_Click</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.JudgeInvalid()</span><br><span class="line">        Content = self.InputContenText.toPlainText()</span><br><span class="line">        OffsetText = self.OffsetText.toPlainText()</span><br><span class="line">        Offset = int(OffsetText)</span><br><span class="line">        Result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> Content:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="string">'a'</span> <span class="keyword">and</span> i &lt;= <span class="string">'z'</span>:</span><br><span class="line">                Result += chr(ord(<span class="string">'a'</span>) + (ord(i)-ord(<span class="string">'a'</span>) - Offset) % <span class="number">26</span>)</span><br><span class="line">            <span class="keyword">elif</span> i &gt;= <span class="string">'A'</span> <span class="keyword">and</span> i &lt;= <span class="string">'Z'</span>:</span><br><span class="line">                Result += chr(ord(<span class="string">'A'</span>) + (ord(i) - ord(<span class="string">'A'</span>) - Offset) % <span class="number">26</span>)</span><br><span class="line">            <span class="keyword">elif</span> i &gt;= <span class="string">'\u4e00'</span> <span class="keyword">and</span> i &lt;= <span class="string">'\u9fff'</span>:</span><br><span class="line">                Result += chr(ord(i) - Offset % <span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Result += i</span><br><span class="line">        self.OutputContentText.setPlainText(Result)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> PyQt </tag>
            
            <tag> QtDesigner </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第六章(访问权限控制)</title>
      <link href="/2020/04/03/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0(%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6)/"/>
      <url>/2020/04/03/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0(%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第六章(访问权限控制)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关</p></blockquote><h1 id="包：库单元"><a href="#包：库单元" class="headerlink" title="包：库单元"></a>包：库单元</h1><blockquote><p>问：为什么设置控制访问<br>   答：1.使用户不触碰不该触碰的部分。2.更改内部实现，不影响客户端程序员。</p></blockquote><p>当编写一个Java源代码文件时，此文件通常被称为<strong>编译单元（或称为转译单元）</strong>。每个编译单元都必须有一个后缀名<font><strong>.java</strong></font>，而编译单元内可以有一个public类，其名称必须与文件的名称相同。<strong>每个编译单元只能有一个public类</strong>，否则编译器就不会接受。如果在该编译单元之外还有额外的类话，那么在包之外的世界无法看见这些类，这时因为它们不是public类，而且它们<strong>主要用来为主public类提供支持</strong>。</p><h1 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h1><p>当编译一个.java文件时，在.java文件中的每个类都会有一个输出文件，其名称与类名称相同，后缀名是<font><strong>.class</strong>。所以，编译少量.java文件之后，往往后得到大量的.class文件。</p><blockquote><p>使用编译型语言编写程序，编译器会产生一个中间文件（通常是<strong>obj文件</strong>），然后再与通过<strong>链接器</strong>（用以创建一个可执行文件）或<strong>类库产生器</strong>（librarian，用以创建一个类库）产生的其他同类文件捆绑在一起。</p></blockquote><p>而Java可运行程序是一组可以打包并压缩为一个<strong>Java文档文件</strong>（JAR，使用Java的jar文档生成器）的.class文件，<strong>Java解释器负责这些文件的查找、装载和解释</strong>。</p><p><strong>务必牢记：package和import关键字允许你做的，是将单一的全局名字空间分割开。</strong></p><h1 id="创建独一无二的包名"><a href="#创建独一无二的包名" class="headerlink" title="创建独一无二的包名"></a>创建独一无二的包名</h1><p><strong>Java解释器的运行过程</strong></p><ol><li>找出环境变量<strong>CLASSPATH</strong>（涉及环境变量需大写），作为根目录</li><li>获取包的名称并将句点转换成反斜杠，以<strong>CLASSPATH</strong>跟中产生一个路径名称（package foo.bar.baz 变成为 foo\bar\baz 或 foo/ bar/baz 或其他，这取决于操作系统）</li><li>解释器在这些目录中查找出你所要创建的类名称相关的.class文件。（解释器还会去查找某些涉及Java解释器所在位置的标准目录。）</li></ol><p><strong>建议：package名称的第一部分是创建者反顺序的Internet域名，第二部分是一个目录名。</strong><br><code>cn.olwician.MindView</code></p><p><strong>注意：对于从包中导入的类以及要使用的方法都必须是public的。</strong></p><h1 id="定制工具库"><a href="#定制工具库" class="headerlink" title="定制工具库"></a>定制工具库</h1><p>可以创建一些<strong>自己的工具库</strong>减少重复的程序代码</p><h1 id="Java访问权限修饰词"><a href="#Java访问权限修饰词" class="headerlink" title="Java访问权限修饰词"></a>Java访问权限修饰词</h1><p>不提供任何访问权限修饰词，则意味着它是<font><strong>“包访问权限”(default或friendly</strong>)。<br>无论如何，<strong>所有事物都具有某种形式的访问权限控制</strong>。</p><h2 id="取得成员的访问权的途径"><a href="#取得成员的访问权的途径" class="headerlink" title="取得成员的访问权的途径"></a>取得成员的访问权的途径</h2><ol><li>使该成员成为<strong>public</strong></li><li>通过不加访问权限修饰词将其他类放置于同一个包内，包内的其他类就能够访问该成员了。</li><li>使用继承技术，继承类能够访问<strong>public</strong>成员也能访问<strong>protected</strong>成员。</li><li>提供访问器（<strong>accessor</strong>）和变异器（<strong>mutator</strong>）方法（<strong>也称作get/set方法</strong>），以读取和改变数值，<strong>对OOP而言，这是最优雅的方式。</strong></li></ol><h2 id="默认包"><a href="#默认包" class="headerlink" title="默认包"></a>默认包</h2><p>两个处于同目录下的类能够互相调用，原因是它们同处于<strong>相同的目录并且没有给自己设定任何包名称</strong>，于是Java将这样的文件自动看作是隶属于该目录的默认包之中。</p><h1 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h1><p><strong>类的访问权限只有两个</strong>：包访问权限或public</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>据估计，用C语言开发项目，在50千行至100千行之间就会出现问题，这是因为C语言仅有单一的“名字空间”，并且名称开始发生冲突，引发额外的管理开销。而对于Java，关键字package、包的命名模式和关键字import，可以使你对名称进行完全的控制，因此名称冲突的问题是很容易避免的。</p></blockquote><blockquote><p>控制对成员的访问权限有两个<strong>原因</strong><br>1.为了使用户不要碰触那些他们不该碰触的部分。<br>2.（<strong>最重要</strong>）为了让类库设计者可以更改类的内部工作方式，而不必担心这样会对客户端程序猿产生重大的影响。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第五章(初始化与清理)</title>
      <link href="/2020/03/30/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0(%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86)/"/>
      <url>/2020/03/30/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0(%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第五章(初始化与清理)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。</p></blockquote><h1 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h1><ul><li>调用构造器是编译器的责任。</li><li>构造器采用与<strong>类相同</strong>的名称。</li><li>在Java中，<font><strong>“初始化”和“创建”</strong></font>捆绑在一起，两者不能分离。</li><li>构造器是一种特殊类型的方法，没有返回值，与返回值为空（void）不同。</li></ul><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><h2 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h2><ul><li>参数类型的差异</li><li>参数顺序的差异 (一般情况<strong>不建议</strong>，因为这会使代码难以维护）</li></ul><h2 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h2><ul><li>实参类型<strong>小于</strong>形参类型，实际数据类型会被提升。<br>无法找到接受char参数的方法时，char直接提升至int型。</li><li>实参类型<strong>大于</strong>形参类型，需通过类型转换来执行<strong>窄化转换</strong>，否则编译器会报错。</li></ul><h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><blockquote><p>问题：<strong>a.peel(1),b.peel(2)</strong>，如何知道是a还是b调用的peel方法?<br>答案：使用this关键字，this可理解为所操作<strong>对象的引用</strong>，作为第一个参数传给peel()，类似于<strong>Banna.peel(a,1)</strong></p></blockquote><h1 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h1><ul><li>必须将构造器调用置于最起始处。</li><li>构造器中只能用this调用一个构造器</li><li>除构造器外，编译器禁止在其他任何方法中调用构造器。</li></ul><h1 id="static的含义"><a href="#static的含义" class="headerlink" title="static的含义"></a>static的含义</h1><p>static方法没有this的方法，因为在<strong>static方法的内部不能调用非静态方法。</strong></p><h1 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h1><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><ul><li><p>只能释放由<strong>new分配</strong>的内存</p></li><li><p>无法释放由并非new创建的对象所占据的内存，以及“本地方法”分配的内存。</p><pre><code>本地方法：在Java中调用了非Java代码，如C的malloc()会分配存储空间</code></pre></li></ul><h2 id="finalize-原理"><a href="#finalize-原理" class="headerlink" title="finalize()原理"></a>finalize()原理</h2><ul><li><p>垃圾回收器追备好释放对象占用的存储空间时，首先调用finalize()，然后垃圾回收动作发生，便会真正地回收对象占用的内存。</p></li><li><p>C++中，对象一定会被销毁，而Java里的对象却<strong>并非总是被垃圾回收</strong></p><ol><li>对象可能不被垃圾回收</li><li>垃圾回收并不等于“析构”</li><li>垃圾回收只与内存有关</li><li>绝对不能直接调用<strong>finalize()</strong></li></ol></li></ul><pre><code>System.gc()用于强制进行终结动作</code></pre><h2 id="垃圾回收器如何工作"><a href="#垃圾回收器如何工作" class="headerlink" title="垃圾回收器如何工作"></a>垃圾回收器如何工作</h2><ul><li><p>垃圾回收器显著提升对象的创建速度——<strong>存储空间的释放会影响存储空间的分配</strong>（Java虚拟机的工作方式）</p></li><li><p><strong>Java虚拟机中的堆的实现</strong>：像是一个<strong>传送带</strong>，每分配一个新对象，它就往前移动一格。（这意味着对象存储空间的分配速度非常快）</p></li><li><p><strong>垃圾回收器工作原理</strong>：一面回收空间，一面使堆中的对象紧凑排列，这样“<strong>堆指针</strong>”就可以很容易移动至更靠近传送带的开始处，也就尽量<strong>避免了页面错误</strong>。通过垃圾回收器对对象重新排列，实现了<strong>一种高速的、有无限空间可分配的堆模型</strong>。</p></li><li><p>Java虚拟机采用自适应的垃圾回收技术</p><ol><li>第一种做法：<strong>停止——复制(stop-and-copy)</strong>：先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。当对象被复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列，然后就可以同上述的方法简单而直接地分配新空间。<br>这种方法效率会降低，<strong>两个原因</strong><br><font><strong>1）</strong></font>需要<strong>两个堆</strong>，从而使得维护比实际需要多一倍的空间，某些Java虚拟机处理方式：从<strong>堆中分配几块较大的内存</strong>，复制动作发生在这些<strong>大块内存之间</strong>。<br><font><strong>2）</strong></font>程序中可能只有少量垃圾，甚至没有垃圾，这进行复制就造成了<strong>浪费</strong>。于是Java虚拟机进行检查，如果没有新垃圾产生，就会转换到另一种工作模式（根据情况转变即“自适应”），被称为<strong>标记——清扫(make-and-sweep)</strong></li><li>第二种做法：<strong>标记——清扫</strong>,从<strong>堆栈</strong>和<strong>静态存储区</strong>出发，遍历所有的引用，进而找出所有存活的对象，每找到一个，便会给对象一个标记。完成所有标记工作之后，便开始清理动作，没有标记的对象会被释放，不会发生任何复制动作，<strong>同时剩下的堆空间是不连续的</strong>。</li></ol><blockquote><p>“停止——复制”不在后台进行，而“标记——清扫”必须在程序暂停的情况下进行。</p></blockquote><blockquote><p>内存分配以较大的“块”为单位，如果对象较大，它会占用单独的块，每个块会用相应的代数来记录它是否存活（这对处理大量短命的临时对象很有帮助）。Java虚拟机会监视，如果对象稳定，效率降低，便会切换到“标记——清扫”方式；如果堆空间出现很多碎片，就会切换到“停止——复制”方式，<strong>这便是“自适应”技术，全称：“自适应的、分代的，停止——复制、标记——清扫”式垃圾回收器</strong>。</p></blockquote></li><li><p>Java虚拟机中有许多附加技术用以提升速度。尤其是与加载器操作有关的，<strong>称为“即时”（JIT，Just-In-Time）编译器技术</strong>。<br>这种技术可以把程序全部或部分翻译成<strong>本地机器码（本是Java虚拟机的工作）</strong>，从而使程序运行速度得到提升。</p></li></ul><p>当装载某个类时，编译器会先找到.class文件，将该类的<strong>字节码装入内存</strong>。<br>此时，有<strong>两个方案</strong>可以选择：<br><font><strong>1)</strong></font>让即时编译器编译所有代码，这做法存在两个<strong>缺陷</strong>：</p><ol><li>加载动作散落在整个程序生命周期内，累加起来要花更多时间。</li><li>增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这导致<strong>页面调度</strong>，从而降低程序速度。</li></ol><p><font><strong>2)</strong></font><strong>惰性评估(lazy evaluation)</strong>，即时编译器只在必要的情况进行编译代码，从而使不会被执行的代码不会被JIT编译。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li>只有第一次访问静态数据时，静态对象才会被初始化</li><li>初始化顺序：<ol><li>静态初始化 static{},首次加载类时执行（即便未生成类对象）</li><li>非静态初始化 {}，生成对象时执行，匿名内部类的初始化（见第十章）</li><li>构造器</li></ol></li></ul><h1 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1;</span><br><span class="line"><span class="keyword">int</span> a1[];</span><br></pre></td></tr></table></figure><p>在Java中<strong>前一种格式更合理</strong>，表明了一个int型数组。</p><ul><li><p>数组的初始化可以由一对花括号括起来的值组成的，其存储空间的分配等价于使用new，由编译器负责。<br><code>int[] a1 = {1,2,3,4,5};</code><br>所有数组都一个<strong>固有成员length</strong>，可以通过它获知数组内包含了多少个元素。</p><blockquote><p>每次访问数组的时候都要检查边界，这一做法在时间和代码上都是需要开销的，无法禁用这个功能。Java设计者认为这种权衡是值得的。尽管你可能会受到诱惑，去编写你认为可以使得数组访问效率提高的代码，但是这一切都是在浪费时间，因为自动的编译期错误和运行时优化都可以提高数组访问的速度。</p></blockquote></li><li><p>数组能够在定义的同时进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">10</span>)];</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#125;;</span><br></pre></td></tr></table></figure><p>初始化列表的最后一个逗号是可选的，这特性使得维护长列表变得更加容易。<br>若创建一个非基本类型的数组，那么就创建了一个<strong>引用数组</strong>（例如Integer是一个类而不是基本类型）</p></li><li><p>可变参数列表，应用于参数个数或类型未知的场合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">(Object... args)</span></span>&#123;&#125;</span><br><span class="line">p(<span class="keyword">new</span> Integer(<span class="number">47</span>),<span class="keyword">new</span> Float(<span class="number">3.14</span>),<span class="keyword">new</span> Double(<span class="number">11.11</span>));</span><br><span class="line">p(<span class="number">47</span>,<span class="number">3.14F</span>,<span class="number">11.11</span>);</span><br><span class="line">p(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>);</span><br><span class="line">p((Object[])<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">p();<span class="comment">//空参数也可以</span></span><br></pre></td></tr></table></figure><p><strong>应该在重载方法的最多一个版本上使用可变参数列表，或者根本不用。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第四章(控制执行流程)</title>
      <link href="/2020/03/26/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B)/"/>
      <url>/2020/03/26/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第四章(控制执行流程)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在Java中，你要使用<strong>执行控制语句</strong>来做出选择。</p></blockquote><blockquote><p>Java并不支持goto语句（该语句引起许多反对意见，但它仍是解决某些特殊问题的最便利的方法）。在Java中，仍然可以进行类似goto那样的跳转，但比起典型的goto，有了很多限制。</p></blockquote><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>在一个控制表达式中，<strong>定义多个变量</strong>的这种能力<strong>只限于for循环适用</strong>，在其他任何选择或迭代语句中都不能适用这种方式。</p><h1 id="Foreach语法"><a href="#Foreach语法" class="headerlink" title="Foreach语法"></a>Foreach语法</h1><p><code>for(float x : f){}</code></p><p>这条语句定义了一个float类型的变量x,继而将每一个f的元素赋值给x。<br>foreach 可用于任何<strong>Iterable对象</strong>。</p><p>例子，<strong>String</strong>类有一个方法<strong>toCharArray()</strong>，它返回一个<strong>char数组</strong>，可以轻易迭代出字符串里面的所有字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachString</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c: <span class="string">"An African Swallow"</span>.toCharArray())</span><br><span class="line">System.out.print(c + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">A n  A f r i c a n  S w a l l o w</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><p>switch要求使用一个<strong>选择因子</strong>，并且必须是<strong>int或char</strong>那样的<strong>整数值</strong>。</p><h1 id="return"><a href="#return" class="headerlink" title="return"></a>return</h1><p><strong>用途</strong></p><ul><li>指定一个方法返回什么值（假设没有void返回值）</li><li>会导致当前的方法退出，并返回那个值。</li></ul><h1 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h1><ul><li>break：强行退出循环，不执行循环中剩余的语句。</li><li>continue：停止当前的迭代，退回至循环起始处，开始下一次迭代。</li></ul><h1 id="臭名昭著的goto"><a href="#臭名昭著的goto" class="headerlink" title="臭名昭著的goto"></a>臭名昭著的goto</h1><blockquote><p>Java编译器生成它自己的“汇编代码”，但是这个代码是运行在<strong>Java虚拟机</strong>上的，而不是直接运行在CPU硬件上。</p></blockquote><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>标签需恰好出现在<strong>迭代语句之前</strong>。</p><blockquote><p>Java里需要使用标签的唯一理由就是因为有<strong>循环嵌套存在</strong>，而且想从多层嵌套中break或continue。通过限制语句的能力，反而能使一项语言特性更加有用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第三章(操作符)</title>
      <link href="/2020/03/25/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0(%E6%93%8D%E4%BD%9C%E7%AC%A6)/"/>
      <url>/2020/03/25/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0(%E6%93%8D%E4%BD%9C%E7%AC%A6)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第三章(操作符)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>在最底层，<strong>Java中的数据是通过使用操作符</strong>来操作的。</p></blockquote><h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><pre><code>在为对象赋值时，实际上是把引用从一个地方复制到另一个地方假设对对象c、d使用c = d,那么c和d都将指向原来只有d指向的那个对象。</code></pre><h1 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equivalence</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">47</span>;</span><br><span class="line"><span class="comment">//System.out.println(equals(n1,n2));</span></span><br><span class="line">System.out.println(n1 != n2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment"> * false</span></span><br><span class="line"><span class="comment"> * true</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>尽管对象的内容相同，然而对象的引用确实不同的，而==和!=比较的就是<strong>对象的引用</strong>。<br>比较对象的实际内容是否相同，需使用特殊方法<strong>equals()</strong>，但是基本类型直接使用==和!=即可，<strong>基本类型不适用与equals()</strong>。</p><h1 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h1><p><strong>短路</strong>：一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。<br><code>test1(0) &amp;&amp; test2(2) &amp;&amp; test3(2)</code></p><p>当test(0)的结果为false，即可判断出这个式子的结果为false，所以余下的test2(2)和test3(2)均不会计算。</p><pre><code>事实上，如果所有的逻辑表达式都有一部分不必计算，那将获得潜在的性能提升。</code></pre><h1 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h1><p>通过使用Integer和Long类的静态方法<font><strong>toBinaryString()</strong></font>可以容易实现将<strong>十六进制</strong>和<strong>八进制</strong>数字以<strong>二进制</strong>形式显示。</p><h1 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h1><blockquote><p>按位操作符来源于<strong>C语言面向底层</strong>的操作，在这种操作中经常需要直接操纵硬件，设置<strong>硬件寄存器内的二进制位</strong>，而Java的设计初衷是<strong>嵌入电视机机顶盒</strong>，于是这种面向底层的操作仍被保留了下来。</p></blockquote><h1 id="类型转换操作符"><a href="#类型转换操作符" class="headerlink" title="类型转换操作符"></a>类型转换操作符</h1><p>通常，表达式中出现的<strong>最大的数据类型</strong>决定了表达式最终结果的数据类型.</p><blockquote><p>如果将一个Float值与一个double值想成，结果就是<strong>double</strong>；如果将一个int和一个long值相加，则结果为<strong>long</strong>。</p></blockquote><h1 id="Java没有sizeof"><a href="#Java没有sizeof" class="headerlink" title="Java没有sizeof"></a>Java没有sizeof</h1><p>C和C++中，sizeof()操作符可以告诉你为数据项分配的字节数，使用sizeof()的最大原因是为了“移植”，因为<strong>不同的数据类型在不同的机器上可能有不同的大小。</strong><br>Java不需要sizeof()，因为所有数据类型在<strong>所有机器中的大小都是相同的</strong>，它已经被设计在语言中了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第二章(一切都是对象)</title>
      <link href="/2020/03/24/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0(%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1)/"/>
      <url>/2020/03/24/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0(%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第二章(一切都是对象)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>尽管Java是基于C++的，但是相比之下，Java是一种更“纯粹”的面向对象程序设计语言。<br>在开始用Java进行设计之前，必须将思想转化到面向对象的世界中来。<br><strong>虽然Java中（几乎）一切都是对象，但是Java仍然存在不属于对象的东西。</strong></p></blockquote><h1 id="用引用操作对象"><a href="#用引用操作对象" class="headerlink" title="用引用操作对象"></a>用引用操作对象</h1><p>使用<font><strong>引用(reference)</strong></font>来进行操作对象</p><pre><code>类比于遥控器（引用）——&gt; 电视机（对象）</code></pre><p>通常，必须对对象采用一种更通用的初始化方法，而Java中字符串可以用<strong>带引号的文本初始化</strong>。</p><h1 id="必须有你创建所有对象"><a href="#必须有你创建所有对象" class="headerlink" title="必须有你创建所有对象"></a>必须有你创建所有对象</h1><h2 id="数据存储区域"><a href="#数据存储区域" class="headerlink" title="数据存储区域"></a>数据存储区域</h2><ul><li>寄存器：最快的存储区，位于处理器内部。Java中不能直接控制，也不能在程序中感受到寄存器存在的任何迹象（C和C++允许向编译器简易寄存器的分配方式）</li><li>堆栈：速度仅次于寄存器，位于通用RAM（随机访问存储器），对象引用存储其中。</li><li>堆：通用内存池，存放对象。</li><li>常量存储：存放在程序代码内部；在嵌入式系统中，存在放在ROM（只读存储器）。</li><li>非RAM存储：流对象和持久化对象。</li></ul><h2 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h2><p>不用<strong>new</strong>创建变量，而是创建一个并非是引用的自动变量<br>这个变量直接存储“值”，并置于<strong>堆栈</strong>中，更加高效。</p><p><img src="https://s1.ax1x.com/2020/03/24/8bzjnx.png" alt="" title="基本类型"></p><h2 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h2><p><strong>BigInteger</strong>和<strong>BigDecimal</strong>，大体属于“包装器类”的范畴，但没有对应的基本类型。<br>这两类变量需使用方法调用来代替运算符。</p><pre><code>BIgInteger支持任意精度的整数BigDecimal支持任意精度的定点数。</code></pre><h1 id="Java中的数组"><a href="#Java中的数组" class="headerlink" title="Java中的数组"></a>Java中的数组</h1><blockquote><p><strong>基本数据类型的数组会被初始化</strong>。<br>Java的主要目标之一是<strong>安全性</strong>，数组会确保初始化，而且不能在它的范围之外被访问。由此的范围检查，换来了安全性和效率的提高，必须以<strong>每个数组上少量的内存开销及运行时的下标检查为代价的</strong>。（Java有时可以优化这些操作）</p></blockquote><h1 id="永远不需要销毁对象"><a href="#永远不需要销毁对象" class="headerlink" title="永远不需要销毁对象"></a>永远不需要销毁对象</h1><p>基本类型变量的<font><strong>作用域(scope)</strong></font>由花括号的位置决定（C、C++、Java）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">96</span>;<span class="comment">// Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译器将会报告变量x已经定义过。所以，在C和C++里将一个较大作用域的变量“隐藏”起来的做法，在Java里是不允许的。因为Java设计者认为这样做会导致程序混乱。</p></blockquote><hr><p><strong>对象不具备生命周期</strong>，用new创建一个Java对象时，它能够存活于作用域之外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String  s = <span class="keyword">new</span> String(<span class="string">"a string"</span>);</span><br><span class="line">&#125; <span class="comment">// End of scope</span></span><br></pre></td></tr></table></figure><blockquote><p>其中引用s在作用域终点便消失了，但是s指向的String对象扔继续占据内存空间。<br>Java有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象，随后，释放这些对象的内存空间，以便供其他新对象使用。这样做就消除了“<strong>内存泄漏</strong>”，这类问题是程序员忘记释放内存而产生的。</p></blockquote><h1 id="创建新的数据类型：类"><a href="#创建新的数据类型：类" class="headerlink" title="创建新的数据类型：类"></a>创建新的数据类型：类</h1><p>属于<strong>基本数据类型的数据成员</strong>会被初始化。<br><strong>非某个类</strong>的字段不会被初始。</p><pre><code>（Java编译会因这类变量没有初始化而返回错误）</code></pre><h1 id="构建一个Java程序"><a href="#构建一个Java程序" class="headerlink" title="构建一个Java程序"></a>构建一个Java程序</h1><p><strong>static关键字</strong>可以满足两方面的需要</p><ul><li>只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。</li><li>希望某个方法不与包含它的类的任何对象关联在一起。即没有创建对象，也能够调用这个方法。</li></ul><h1 id="注释和嵌入式文档"><a href="#注释和嵌入式文档" class="headerlink" title="注释和嵌入式文档"></a>注释和嵌入式文档</h1><p>javadoc命令在“/<em>*”注释中出现，结束于“</em>/”<br>javadoc只能为public、protected注释</p><pre><code>可用-private进行标记，对private成员添加注释</code></pre><p><strong>标签示例</strong></p><ul><li>@see：引用其他类</li><li>{@link package.class#member}：使用行内label作为超链接文本</li><li>{@docRoot}：产生到文档根目录的相对路径，用于文档树页面的显式超链接</li><li>{@inheritDoc}：从当前类的最直接的基类中继承相关文档到当前文档注释中</li><li>@version：显示包含在版本说明中的重要信息</li><li>@author：显示你的姓名或任何合适的信息</li><li>@since：允许指定程序代码最早使用的版本</li><li>@param：方法的参数列表中的标识符 + 可延续数行的文本<br><code>@param parameter-name description</code></li><li>@return：描述返回值的含义</li><li>@throws：一个异常类的无歧义的名字 + 可延续数行的文本<br><code>@throws fully-qualified-class-name description</code></li></ul><h1 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h1><p>采用“<strong>驼峰风格</strong>”：类名内部单词首字母大写，而其他内容标识符第一个字母小写。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第一章(对象导论)</title>
      <link href="/2020/03/21/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0(%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA)/"/>
      <url>/2020/03/21/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0(%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第一章(对象导论)的概括总结</p></blockquote><a id="more"></a><hr><h1 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h1><p><strong>汇编语言</strong>：底层机器的轻微抽象。<br><strong>“命令式”语言</strong>：汇编语言的抽象。所作的主要抽象在解决问题基于计算机的结构，而不是基于所要解决的问题的结构。</p><p><strong>只针对待解问题建模</strong>：</p><p>1、早期的编程语言-<strong>LISP</strong>和<strong>APL</strong>，它们选择考虑世界的某些特定视图。</p><ul><li>LISP-所有问题最终都是列表；APL-所有问题都是算法形式的。</li><li>但是他们无法解决超期特定领域的问题。</li></ul><p>2、面向对象方式（OOP），对象即问题空间中的元素，不会受限于任何特定类型的问题。</p><p>第一个成功的OOP语言的五个基本特性：<br>1、万物皆为对象。<br>2、程序是对象的结合，它们通过发送消息来告知彼此所要做的。<br>3、每个对象都有自己的由其他对象所构成的存储。<br>4、每个对象都拥有其类型。<br>5、某一特定类型的所有对象都可以接受同样的消息。</p><hr><h1 id="每个对象都一个接口"><a href="#每个对象都一个接口" class="headerlink" title="每个对象都一个接口"></a>每个对象都一个接口</h1><p><strong>类</strong>：问题空间的元素&lt;—&gt;解空间的对象，即它们之间的映射。<br><strong>接口</strong>：确定对某一特定对象所能发出的请求。</p><hr><h1 id="每个对象都提供服务"><a href="#每个对象都提供服务" class="headerlink" title="每个对象都提供服务"></a>每个对象都提供服务</h1><p>将对象想象为<strong>服务提供者</strong><br>1、用户正在使用程序提供的服务，而程序在通过调用其他对象提供的服务来实现程序服务供应。<br>2、有助于提高对象的<strong>内聚性</strong>，即对象不试图做更多的事。</p><hr><h1 id="被隐藏的具体实现"><a href="#被隐藏的具体实现" class="headerlink" title="被隐藏的具体实现"></a>被隐藏的具体实现</h1><p>开发人员可分为<strong>类创建者</strong>和<strong>客户端程序员</strong></p><ul><li>类创建者可类比为Java语言库开发者</li><li>客户端程序员则是有我这样的入门程序猿。</li></ul><hr><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>设置访问控制的<strong>原因</strong>有</p><ul><li>让客户端程序员无法触及他们不应该触及的部分。</li><li>允许库设计者可以改变类内部的工作方式而不影响到客户端程序员。</li></ul><p><strong>关键字</strong></p><ul><li><strong>public</strong>：所有人都可以访问</li><li><strong>private</strong>：只有自己可以访问</li><li><strong>protected</strong>：继承的类可访问</li><li><strong>default</strong>：同一个包内可访问</li></ul><hr><h1 id="复用具体实现"><a href="#复用具体实现" class="headerlink" title="复用具体实现"></a>复用具体实现</h1><p><strong>组合</strong>：使用现有的类合成新的类，新类的成员对象通常被声明为private，具有灵活性。<br><strong>继承</strong>：不具备组合的灵活性，编译器会对继承类施加编译时的限制。</p><hr><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>基类和导出类之间的<strong>差异</strong>在于：</p><ul><li>导出类可拥有新方法。</li><li>导出类可覆盖基类的方法。</li></ul><hr><h1 id="伴随多态的可互换对象"><a href="#伴随多态的可互换对象" class="headerlink" title="伴随多态的可互换对象"></a>伴随多态的可互换对象</h1><blockquote><p>处理层次结构时，将对象当做基类对待而不是特定类型，例如关心几何形状的特性：都可以被绘制、擦除和移动，因为几何形状能做的，圆形、正方形、三角形都可以实现。</p></blockquote><p><strong>函数调用</strong>分为两种</p><ul><li><strong>前期绑定</strong>，这属于非面向对象编程，它运行代码的绝对地址。</li><li><strong>后期绑定</strong>，这属于OOP，编译器会确保调用方法的存在，来计算代码的地址。Java为实现后期绑定，使用了一段特殊的代码在对象中存储的信息来计算方法体的地址。<blockquote><p>C++中使用virtual关键字实现动态绑定，而Java中是默认的。</p></blockquote></li></ul><p><strong>向上转型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Shape shape)</span></span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br><span class="line">Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">doSomething(circle);</span><br></pre></td></tr></table></figure><p>其中<strong>Shape</strong>是基类，而<strong>Circle</strong>是继承类，最终代码会调用<strong>Circle</strong>的<strong>draw</strong>方法，程序在运行中得知<strong>Circle</strong>是一个<strong>Shape</strong>，并且知道调用<strong>Circle</strong>中的<strong>draw</strong>方法而不是直接调用<strong>Shape</strong>的<strong>draw</strong>方法。</p><blockquote><p>这就是多态的神奇之处。</p></blockquote><hr><h1 id="单根继承结构"><a href="#单根继承结构" class="headerlink" title="单根继承结构"></a>单根继承结构</h1><blockquote><p>所有OOP语言都拥有一个最终基类（所有类都继承的类），在Java中为Object。</p></blockquote><p>这一结构有许多<strong>好处</strong></p><ul><li>保证所有对象具有某些功能</li><li>极大简化参数传递</li><li>容易实现垃圾回收</li></ul><hr><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><blockquote><p><strong>Java</strong>中的容器有许多，例如：<strong>List</strong>、<strong>Map</strong>、<strong>Set</strong>。</p></blockquote><p>设置不同的容器有两个<strong>原因</strong></p><ul><li>不同容器提供了不同类型的接口和外部行为</li><li>不同容器对于某些操作具有不同的效率，ArrayList和LinkedList在访问数据和插入数据有着天壤地别的效率差距。</li></ul><p><strong>向下转型</strong>：从<strong>Object</strong>转变成具体类型。</p><p>参数化类型（范型）<br>可以使用下面语句来创建一个存储Shape的ArrayList<br><code>ArrayList&lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;();</code></p><hr><h1 id="对象的创建和生命期"><a href="#对象的创建和生命期" class="headerlink" title="对象的创建和生命期"></a>对象的创建和生命期</h1><p><font><strong>C++</strong></font><br>为了追求最大的执行速度，在编写时确定了存储空间、生命周期.<br>存储空间为<strong>堆栈</strong>和<strong>静态存储区</strong>，但是这样牺牲了灵活性。</p><p><strong>Java</strong><br>采用了动态内存分配方式，对象存放在<strong>堆的内存池</strong>中。</p><blockquote><p>动态方式存在一个逻辑假设：对象趋向于变得十分复杂，所以查找和释放存储空间的开销在对象的创建面前影响很小。</p></blockquote><hr><h1 id="异常处理：处理错误"><a href="#异常处理：处理错误" class="headerlink" title="异常处理：处理错误"></a>异常处理：处理错误</h1><p>异常处理将错误处理置于编程语言中，甚至置于操作系统中。<br><strong>Java</strong>内置异常处理，并且<strong>强制使用</strong>。</p><blockquote><p>异常处理在非面向对象语言中就已经存在。</p></blockquote><hr><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>多个并发任务访问同一项资源，需使用<strong>线程锁</strong>来解决问题。<br><strong>Java</strong>的并发是内置的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(C)实现SM4国密算法</title>
      <link href="/2020/03/16/%5BC%5D%E5%AE%9E%E7%8E%B0sm4%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/16/%5BC%5D%E5%AE%9E%E7%8E%B0sm4%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于上篇<strong>SM3国密算法</strong>改编而成。</p></blockquote><a id="more"></a><hr><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li><p>全称：“SM4分组密码算法”，其中sm是<strong>商用密码</strong>的拼音简称。</p><p> 以下是算法文字说明<br> 大致思想与AES-128一致</p></li></ul><h1 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h1><p><img src="https://s1.ax1x.com/2020/03/16/8GgZYn.jpg" alt="" title="说明1"></p><hr><p><img src="https://s1.ax1x.com/2020/03/16/8GgeWq.jpg" alt="" title="说明2"></p><hr><p><img src="https://s1.ax1x.com/2020/03/16/8GgnS0.jpg" alt="" title="说明3"></p><hr><p><img src="https://s1.ax1x.com/2020/03/16/8GgKyT.jpg" alt="" title="说明4"></p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font size = 3>定义</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义无符号整型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsign32 unsigned int</span></span><br><span class="line"><span class="comment">//定义sm3结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">unsign32 k[<span class="number">40</span>];</span><br><span class="line">unsign32 rk[<span class="number">40</span>];</span><br><span class="line">unsign32 x[<span class="number">40</span>];</span><br><span class="line">unsign32 h[<span class="number">4</span>];</span><br><span class="line">&#125; sm4;</span><br><span class="line"></span><br><span class="line"><span class="comment">//S盒 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Sbox[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x90</span>,<span class="number">0xe9</span>,<span class="number">0xfe</span>,<span class="number">0xcc</span>,<span class="number">0xe1</span>,<span class="number">0x3d</span>,<span class="number">0xb7</span>,<span class="number">0x16</span>,<span class="number">0xb6</span>,<span class="number">0x14</span>,<span class="number">0xc2</span>,<span class="number">0x28</span>,<span class="number">0xfb</span>,<span class="number">0x2c</span>,<span class="number">0x05</span>,</span><br><span class="line"><span class="number">0x2b</span>,<span class="number">0x67</span>,<span class="number">0x9a</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0xbe</span>,<span class="number">0x04</span>,<span class="number">0xc3</span>,<span class="number">0xaa</span>,<span class="number">0x44</span>,<span class="number">0x13</span>,<span class="number">0x26</span>,<span class="number">0x49</span>,<span class="number">0x86</span>,<span class="number">0x06</span>,<span class="number">0x99</span>,</span><br><span class="line"><span class="number">0x9c</span>,<span class="number">0x42</span>,<span class="number">0x50</span>,<span class="number">0xf4</span>,<span class="number">0x91</span>,<span class="number">0xef</span>,<span class="number">0x98</span>,<span class="number">0x7a</span>,<span class="number">0x33</span>,<span class="number">0x54</span>,<span class="number">0x0b</span>,<span class="number">0x43</span>,<span class="number">0xed</span>,<span class="number">0xcf</span>,<span class="number">0xac</span>,<span class="number">0x62</span>,</span><br><span class="line"><span class="number">0xe4</span>,<span class="number">0xb3</span>,<span class="number">0x1c</span>,<span class="number">0xa9</span>,<span class="number">0xc9</span>,<span class="number">0x08</span>,<span class="number">0xe8</span>,<span class="number">0x95</span>,<span class="number">0x80</span>,<span class="number">0xdf</span>,<span class="number">0x94</span>,<span class="number">0xfa</span>,<span class="number">0x75</span>,<span class="number">0x8f</span>,<span class="number">0x3f</span>,<span class="number">0xa6</span>,</span><br><span class="line"><span class="number">0x47</span>,<span class="number">0x07</span>,<span class="number">0xa7</span>,<span class="number">0xfc</span>,<span class="number">0xf3</span>,<span class="number">0x73</span>,<span class="number">0x17</span>,<span class="number">0xba</span>,<span class="number">0x83</span>,<span class="number">0x59</span>,<span class="number">0x3c</span>,<span class="number">0x19</span>,<span class="number">0xe6</span>,<span class="number">0x85</span>,<span class="number">0x4f</span>,<span class="number">0xa8</span>,</span><br><span class="line"><span class="number">0x68</span>,<span class="number">0x6b</span>,<span class="number">0x81</span>,<span class="number">0xb2</span>,<span class="number">0x71</span>,<span class="number">0x64</span>,<span class="number">0xda</span>,<span class="number">0x8b</span>,<span class="number">0xf8</span>,<span class="number">0xeb</span>,<span class="number">0x0f</span>,<span class="number">0x4b</span>,<span class="number">0x70</span>,<span class="number">0x56</span>,<span class="number">0x9d</span>,<span class="number">0x35</span>,</span><br><span class="line"><span class="number">0x1e</span>,<span class="number">0x24</span>,<span class="number">0x0e</span>,<span class="number">0x5e</span>,<span class="number">0x63</span>,<span class="number">0x58</span>,<span class="number">0xd1</span>,<span class="number">0xa2</span>,<span class="number">0x25</span>,<span class="number">0x22</span>,<span class="number">0x7c</span>,<span class="number">0x3b</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x78</span>,<span class="number">0x87</span>,</span><br><span class="line"><span class="number">0xd4</span>,<span class="number">0x00</span>,<span class="number">0x46</span>,<span class="number">0x57</span>,<span class="number">0x9f</span>,<span class="number">0xd3</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,<span class="number">0x4c</span>,<span class="number">0x36</span>,<span class="number">0x02</span>,<span class="number">0xe7</span>,<span class="number">0xa0</span>,<span class="number">0xc4</span>,<span class="number">0xc8</span>,<span class="number">0x9e</span>,</span><br><span class="line"><span class="number">0xea</span>,<span class="number">0xbf</span>,<span class="number">0x8a</span>,<span class="number">0xd2</span>,<span class="number">0x40</span>,<span class="number">0xc7</span>,<span class="number">0x38</span>,<span class="number">0xb5</span>,<span class="number">0xa3</span>,<span class="number">0xf7</span>,<span class="number">0xf2</span>,<span class="number">0xce</span>,<span class="number">0xf9</span>,<span class="number">0x61</span>,<span class="number">0x15</span>,<span class="number">0xa1</span>,</span><br><span class="line"><span class="number">0xe0</span>,<span class="number">0xae</span>,<span class="number">0x5d</span>,<span class="number">0xa4</span>,<span class="number">0x9b</span>,<span class="number">0x34</span>,<span class="number">0x1a</span>,<span class="number">0x55</span>,<span class="number">0xad</span>,<span class="number">0x93</span>,<span class="number">0x32</span>,<span class="number">0x30</span>,<span class="number">0xf5</span>,<span class="number">0x8c</span>,<span class="number">0xb1</span>,<span class="number">0xe3</span>,</span><br><span class="line"><span class="number">0x1d</span>,<span class="number">0xf6</span>,<span class="number">0xe2</span>,<span class="number">0x2e</span>,<span class="number">0x82</span>,<span class="number">0x66</span>,<span class="number">0xca</span>,<span class="number">0x60</span>,<span class="number">0xc0</span>,<span class="number">0x29</span>,<span class="number">0x23</span>,<span class="number">0xab</span>,<span class="number">0x0d</span>,<span class="number">0x53</span>,<span class="number">0x4e</span>,<span class="number">0x6f</span>,</span><br><span class="line"><span class="number">0xd5</span>,<span class="number">0xdb</span>,<span class="number">0x37</span>,<span class="number">0x45</span>,<span class="number">0xde</span>,<span class="number">0xfd</span>,<span class="number">0x8e</span>,<span class="number">0x2f</span>,<span class="number">0x03</span>,<span class="number">0xff</span>,<span class="number">0x6a</span>,<span class="number">0x72</span>,<span class="number">0x6d</span>,<span class="number">0x6c</span>,<span class="number">0x5b</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x8d</span>,<span class="number">0x1b</span>,<span class="number">0xaf</span>,<span class="number">0x92</span>,<span class="number">0xbb</span>,<span class="number">0xdd</span>,<span class="number">0xbc</span>,<span class="number">0x7f</span>,<span class="number">0x11</span>,<span class="number">0xd9</span>,<span class="number">0x5c</span>,<span class="number">0x41</span>,<span class="number">0x1f</span>,<span class="number">0x10</span>,<span class="number">0x5a</span>,<span class="number">0xd8</span>,</span><br><span class="line"><span class="number">0x0a</span>,<span class="number">0xc1</span>,<span class="number">0x31</span>,<span class="number">0x88</span>,<span class="number">0xa5</span>,<span class="number">0xcd</span>,<span class="number">0x7b</span>,<span class="number">0xbd</span>,<span class="number">0x2d</span>,<span class="number">0x74</span>,<span class="number">0xd0</span>,<span class="number">0x12</span>,<span class="number">0xb8</span>,<span class="number">0xe5</span>,<span class="number">0xb4</span>,<span class="number">0xb0</span>,</span><br><span class="line"><span class="number">0x89</span>,<span class="number">0x69</span>,<span class="number">0x97</span>,<span class="number">0x4a</span>,<span class="number">0x0c</span>,<span class="number">0x96</span>,<span class="number">0x77</span>,<span class="number">0x7e</span>,<span class="number">0x65</span>,<span class="number">0xb9</span>,<span class="number">0xf1</span>,<span class="number">0x09</span>,<span class="number">0xc5</span>,<span class="number">0x6e</span>,<span class="number">0xc6</span>,<span class="number">0x84</span>,</span><br><span class="line"><span class="number">0x18</span>,<span class="number">0xf0</span>,<span class="number">0x7d</span>,<span class="number">0xec</span>,<span class="number">0x3a</span>,<span class="number">0xdc</span>,<span class="number">0x4d</span>,<span class="number">0x20</span>,<span class="number">0x79</span>,<span class="number">0xee</span>,<span class="number">0x5f</span>,<span class="number">0x3e</span>,<span class="number">0xd7</span>,<span class="number">0xcb</span>,<span class="number">0x39</span>,<span class="number">0x48</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CK为固定参数 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> CK[<span class="number">32</span>] = &#123;</span><br><span class="line"><span class="number">0x00070e15</span>, <span class="number">0x1c232a31</span>, <span class="number">0x383f464d</span>, <span class="number">0x545b6269</span>,</span><br><span class="line"><span class="number">0x70777e85</span>, <span class="number">0x8c939aa1</span>, <span class="number">0xa8afb6bd</span>, <span class="number">0xc4cbd2d9</span>,</span><br><span class="line"><span class="number">0xe0e7eef5</span>, <span class="number">0xfc030a11</span>, <span class="number">0x181f262d</span>, <span class="number">0x343b4249</span>,</span><br><span class="line"><span class="number">0x50575e65</span>, <span class="number">0x6c737a81</span>, <span class="number">0x888f969d</span>, <span class="number">0xa4abb2b9</span>,</span><br><span class="line"><span class="number">0xc0c7ced5</span>, <span class="number">0xdce3eaf1</span>, <span class="number">0xf8ff060d</span>, <span class="number">0x141b2229</span>,</span><br><span class="line"><span class="number">0x30373e45</span>, <span class="number">0x4c535a61</span>, <span class="number">0x686f767d</span>, <span class="number">0x848b9299</span>,</span><br><span class="line"><span class="number">0xa0a7aeb5</span>, <span class="number">0xbcc3cad1</span>, <span class="number">0xd8dfe6ed</span>, <span class="number">0xf4fb0209</span>,</span><br><span class="line"><span class="number">0x10171e25</span>, <span class="number">0x2c333a41</span>, <span class="number">0x484f565d</span>, <span class="number">0x646b7279</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FK为系统参数 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> FK[<span class="number">4</span>] = &#123; <span class="number">0xa3b1bac6</span>L,<span class="number">0x56aa3350</span>L,<span class="number">0x677d9197</span>L,<span class="number">0xb27022dc</span>L &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左循环</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x,n)(((x)<span class="meta-string">&lt;&lt;n) | ((x)&gt;&gt;(32-n)))</span></span></span><br><span class="line"><span class="comment">//字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clip0(x)(( (x)&gt;&gt;24 ) &amp; 0xffL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clip1(x)(( ( (x)<span class="meta-string">&lt;&lt;8 )&gt;&gt;24) &amp; 0xffL)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clip2(x)(( ( (x)<span class="meta-string">&lt;&lt;16 )&gt;&gt;24) &amp; 0xffL)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clip3(x)(( ( (x)<span class="meta-string">&lt;&lt;24 )&gt;&gt;24) &amp; 0xffL)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性变换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L0(b)((b) ^ l(b,2) ^ l(b,10) ^ l(b,18) ^ l(b,24))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L1(b)((b) ^ l(b,13) ^ l(b,23))</span></span><br><span class="line"><span class="comment">//非线性变换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(b)( (Sbox[Clip0(b)] &lt;&lt; 24) | (Sbox[Clip1(b)] &lt;&lt; 16) | (Sbox[Clip2(b)] &lt;&lt; 8) | (Sbox[Clip3(b)]) )</span></span><br><span class="line"><span class="comment">//合成置换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T0(b)(L0(S(b)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T1(b)(L1(S(b)))</span></span><br></pre></td></tr></table></figure><h2 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a><font size = 3>初始化函数</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_init</span><span class="params">(sm4 * sm)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">sm-&gt;x[i] = <span class="number">0L</span>;</span><br><span class="line">sm-&gt;k[i] = <span class="number">0L</span>;</span><br><span class="line">sm-&gt;rk[i] = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">sm-&gt;h[i] = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加工函数"><a href="#加工函数" class="headerlink" title="加工函数"></a><font size = 3>加工函数</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加工函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_process</span><span class="params">(sm4 *sm,unsign32 bt,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = (num / <span class="number">4</span>);<span class="comment">//每个字4个字节，32位；16个字大小为512位</span></span><br><span class="line"></span><br><span class="line">sm-&gt;x[k] &lt;&lt;= <span class="number">8</span>;<span class="comment">//左移8位</span></span><br><span class="line">sm-&gt;x[k] |= (unsign32)(bt &amp; <span class="number">0xff</span>);<span class="comment">//保持补码的一致性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="密钥扩展函数"><a href="#密钥扩展函数" class="headerlink" title="密钥扩展函数"></a><font size = 3>密钥扩展函数</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//密钥扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_extend</span><span class="params">(sm4 * sm)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">sm-&gt;k[<span class="number">0</span>] = sm-&gt;x[<span class="number">0</span>] ^ FK[<span class="number">0</span>];</span><br><span class="line">sm-&gt;k[<span class="number">1</span>] = sm-&gt;x[<span class="number">1</span>] ^ FK[<span class="number">1</span>];</span><br><span class="line">sm-&gt;k[<span class="number">2</span>] = sm-&gt;x[<span class="number">2</span>] ^ FK[<span class="number">2</span>];</span><br><span class="line">sm-&gt;k[<span class="number">3</span>] = sm-&gt;x[<span class="number">3</span>] ^ FK[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">sm-&gt;k[i + <span class="number">4</span>] = sm-&gt;k[i] ^ T1(sm-&gt;k[i + <span class="number">1</span>] ^ sm-&gt;k[i + <span class="number">2</span>] ^ sm-&gt;k[i + <span class="number">3</span>] ^ CK[i]);</span><br><span class="line">sm-&gt;rk[i] = sm-&gt;k[i + <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a><font size = 3>加密函数</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加密函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_encrypt</span><span class="params">(sm4 * sm,unsign32 *Ciphertext)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">sm-&gt;x[i + <span class="number">4</span>] = sm-&gt;x[i] ^ T0(sm-&gt;x[i + <span class="number">1</span>] ^ sm-&gt;x[i + <span class="number">2</span>] ^ sm-&gt;x[i + <span class="number">3</span>] ^ sm-&gt;rk[i]);</span><br><span class="line">&#125;</span><br><span class="line">Ciphertext[<span class="number">0</span>] = sm-&gt;x[<span class="number">35</span>];</span><br><span class="line">Ciphertext[<span class="number">1</span>] = sm-&gt;x[<span class="number">34</span>];</span><br><span class="line">Ciphertext[<span class="number">2</span>] = sm-&gt;x[<span class="number">33</span>];</span><br><span class="line">Ciphertext[<span class="number">3</span>] = sm-&gt;x[<span class="number">32</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解密函数"><a href="#解密函数" class="headerlink" title="解密函数"></a><font size = 3>解密函数</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解密函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_decrypt</span><span class="params">(sm4 * sm, unsign32 *Ciphertext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;<span class="comment">//解密结构与加密相同，只有轮密钥为倒序</span></span><br><span class="line">sm-&gt;x[i + <span class="number">4</span>] = sm-&gt;x[i] ^ T0(sm-&gt;x[i + <span class="number">1</span>] ^ sm-&gt;x[i + <span class="number">2</span>] ^ sm-&gt;x[i + <span class="number">3</span>] ^ sm-&gt;rk[<span class="number">31</span>-i]);</span><br><span class="line">&#125;</span><br><span class="line">Ciphertext[<span class="number">0</span>] = sm-&gt;x[<span class="number">35</span>];</span><br><span class="line">Ciphertext[<span class="number">1</span>] = sm-&gt;x[<span class="number">34</span>];</span><br><span class="line">Ciphertext[<span class="number">2</span>] = sm-&gt;x[<span class="number">33</span>];</span><br><span class="line">Ciphertext[<span class="number">3</span>] = sm-&gt;x[<span class="number">32</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口封装函数"><a href="#接口封装函数" class="headerlink" title="接口封装函数"></a><font size = 3>接口封装函数</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口封装</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_hash</span><span class="params">(unsign32 *test, unsign32 *test1, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 当n为1时，进行加密；当n为0时，进行解密。 */</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">sm4 sm;</span><br><span class="line">sm4_init(&amp;sm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">sm4_process(&amp;sm, test[i], i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sm4_extend(&amp;sm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n) &#123;</span><br><span class="line">sm4_encrypt(&amp;sm, sm.h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//解密需获取加密明文的轮密钥</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">sm4_process(&amp;sm, test1[i], i);</span><br><span class="line">&#125;</span><br><span class="line">sm4_decrypt(&amp;sm, sm.h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">1</span>) &#123;</span><br><span class="line">test[i] = Clip0(sm.h[i / <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">2</span>) &#123;</span><br><span class="line">test[i] = Clip1(sm.h[i / <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">3</span>) &#123;</span><br><span class="line">test[i] = Clip2(sm.h[i / <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">test[i] = Clip3(sm.h[i / <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02x "</span>, test[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(C)实现SM3国密算法</title>
      <link href="/2020/03/09/%5BC%5D%E5%AE%9E%E7%8E%B0sm3%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/09/%5BC%5D%E5%AE%9E%E7%8E%B0sm3%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于<strong>mircal</strong>库中的<strong>SHA-256</strong>算法改编而成。</p></blockquote><a id="more"></a><hr><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li><p>全称：“SM3密码杂凑算法”<em>(SM3 Cryptographic Hash Algorithm)</em>，其中sm是<strong>商用密码</strong>的拼音简称。</p><p> 以下是算法文字说明<br> 大致思想与SHA-256一致</p></li></ul><h1 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h1><p><img src="https://s2.ax1x.com/2020/03/09/89hnG8.jpg" alt="" title="说明1"></p><hr><p><img src="https://s2.ax1x.com/2020/03/09/89hZIP.jpg" alt="" title="说明2"></p><hr><p><img src="https://s2.ax1x.com/2020/03/09/89hmPf.jpg" alt="" title="说明3"></p><hr><p><img src="https://s2.ax1x.com/2020/03/09/89hVat.jpg" alt="" title="说明4"></p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font size = 3>定义</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义无符号整型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsign32 unsigned int</span></span><br><span class="line"><span class="comment">//定义sm3结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">unsign32 length[<span class="number">2</span>];<span class="comment">//保证消息长度满足条件：L &lt; 2^32</span></span><br><span class="line">unsign32 h[<span class="number">8</span>];   <span class="comment">//记录生成的杂凑值</span></span><br><span class="line">unsign32 w0[<span class="number">80</span>];</span><br><span class="line">unsign32 w1[<span class="number">80</span>];</span><br><span class="line">&#125; sm3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zero 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pad 0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T0 0x79cc4519L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T1 0x7a879d8aL</span></span><br><span class="line"><span class="comment">//定义初始值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> unsign32 InitNum[<span class="number">8</span>] = &#123;</span><br><span class="line"><span class="number">0x7380166f</span>L,<span class="number">0x4914b2b9</span>L,<span class="number">0x172442d7</span>L,<span class="number">0xda8a0600</span>L,</span><br><span class="line"><span class="number">0xa96f30bc</span>L,<span class="number">0x163138aa</span>L,<span class="number">0xe38dee4d</span>L,<span class="number">0xb0fb0e4e</span>L</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义布尔函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF0(X,Y,Z)  ((X)^(Y)^(Z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF1(X,Y,Z)((X&amp;Y)|(X&amp;Z)|(Y&amp;Z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GG0(X,Y,Z)((X)^(Y)^(Z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GG1(X,Y,Z)((X&amp;Y)|(~(X)&amp;Z))</span></span><br><span class="line"><span class="comment">//定义置换函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(X,n)(((X)<span class="meta-string">&lt;&lt;n) | ((X)&gt;&gt;(32-n)))</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P0(X)((X)^L(X,9)^L(X,17))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P1(X)((X)^L(X,15)^L(X,23))</span></span><br></pre></td></tr></table></figure><h2 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a><font size = 3>初始化函数</font></h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm3_init</span><span class="params">(sm3 *sm)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">80</span>; i++) &#123;</span><br><span class="line">sm-&gt;w0[i] = <span class="number">0L</span>;</span><br><span class="line">sm-&gt;w1[i] = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line">sm-&gt;length[<span class="number">0</span>] = sm-&gt;length[<span class="number">1</span>] = <span class="number">0L</span>;</span><br><span class="line">sm-&gt;h[<span class="number">0</span>] = InitNum[<span class="number">0</span>]; sm-&gt;h[<span class="number">1</span>] = InitNum[<span class="number">1</span>];</span><br><span class="line">sm-&gt;h[<span class="number">2</span>] = InitNum[<span class="number">2</span>]; sm-&gt;h[<span class="number">3</span>] = InitNum[<span class="number">3</span>];</span><br><span class="line">sm-&gt;h[<span class="number">4</span>] = InitNum[<span class="number">4</span>]; sm-&gt;h[<span class="number">5</span>] = InitNum[<span class="number">5</span>];</span><br><span class="line">sm-&gt;h[<span class="number">6</span>] = InitNum[<span class="number">6</span>]; sm-&gt;h[<span class="number">7</span>] = InitNum[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加工函数"><a href="#加工函数" class="headerlink" title="加工函数"></a><font size = 3>加工函数</font></h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//加工函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm3_process</span><span class="params">(sm3 *sm,<span class="keyword">int</span> bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = (<span class="keyword">int</span>)((sm-&gt;length[<span class="number">0</span>] / <span class="number">32</span>) % <span class="number">16</span>);<span class="comment">//每个字4个字节，32位；16个字大小为512位</span></span><br><span class="line"></span><br><span class="line">sm-&gt;w0[k] &lt;&lt;= <span class="number">8</span>;<span class="comment">//左移8位</span></span><br><span class="line">sm-&gt;w0[k] |= (unsign32)(bt &amp; <span class="number">0xff</span>);<span class="comment">//保持补码的一致性</span></span><br><span class="line"></span><br><span class="line">sm-&gt;length[<span class="number">0</span>] += <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (sm-&gt;length[<span class="number">0</span>] == <span class="number">0L</span>) &#123;<span class="comment">//无符号整型溢出将进行舍弃最高位的操作</span></span><br><span class="line">sm-&gt;length[<span class="number">1</span>]++;  <span class="comment">//消息长度需小于2^64，所以2个字足够保证记录消息长度</span></span><br><span class="line">sm-&gt;length[<span class="number">0</span>] = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((sm-&gt;length[<span class="number">0</span>] % <span class="number">512</span>) == <span class="number">0</span>) &#123;<span class="comment">//若消息长度超过512，便直接对其前面16个字进行处理</span></span><br><span class="line">sm3_transform(sm); <span class="comment">//降低算法复杂度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a><font size = 3>转换函数</font></h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm3_transform</span><span class="params">(sm3 *sm)</span> </span>&#123;</span><br><span class="line">unsign32 A, B, C, D, E, F, G, H, SS1, SS2, TT1, TT2;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">16</span>; i &lt; <span class="number">68</span>; i++) &#123;</span><br><span class="line">sm-&gt;w0[i] = P1(sm-&gt;w0[i - <span class="number">16</span>] ^ sm-&gt;w0[i - <span class="number">9</span>] ^ (L(sm-&gt;w0[i - <span class="number">3</span>], <span class="number">15</span>))) ^ L(sm-&gt;w0[i - <span class="number">13</span>], <span class="number">7</span>) ^ sm-&gt;w0[i - <span class="number">6</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">sm-&gt;w1[i] = sm-&gt;w0[i] ^ sm-&gt;w0[i + <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A = sm-&gt;h[<span class="number">0</span>]; B = sm-&gt;h[<span class="number">1</span>]; C = sm-&gt;h[<span class="number">2</span>]; D = sm-&gt;h[<span class="number">3</span>];</span><br><span class="line">E = sm-&gt;h[<span class="number">4</span>]; F = sm-&gt;h[<span class="number">5</span>]; G = sm-&gt;h[<span class="number">6</span>]; H = sm-&gt;h[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">SS1 = (i&lt;=<span class="number">15</span>) ? L(L(A, <span class="number">12</span>) + E + L(T0, i), <span class="number">7</span>) : L(L(A, <span class="number">12</span>) + E + L(T1, i), <span class="number">7</span>);</span><br><span class="line">SS2 = (SS1) ^ L(A, <span class="number">12</span>);</span><br><span class="line">TT1 = (i&lt;=<span class="number">15</span>) ? FF0(A, B, C) + D + SS2 + sm-&gt;w1[i] : FF1(A, B, C) + D + SS2 + sm-&gt;w1[i];</span><br><span class="line">TT2 = (i&lt;=<span class="number">15</span>) ? GG0(E, F, G) + H + SS1 + sm-&gt;w0[i] : GG1(E, F, G) + H + SS1 + sm-&gt;w0[i];</span><br><span class="line">D = C;</span><br><span class="line">C = L(B, <span class="number">9</span>);</span><br><span class="line">B = A;</span><br><span class="line">A = TT1;</span><br><span class="line">H = G;</span><br><span class="line">G = L(F, <span class="number">19</span>);</span><br><span class="line">F = E;</span><br><span class="line">E = P0(TT2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sm-&gt;h[<span class="number">0</span>] ^= A; sm-&gt;h[<span class="number">1</span>] ^= B; sm-&gt;h[<span class="number">2</span>] ^= C; sm-&gt;h[<span class="number">3</span>] ^= D;</span><br><span class="line">sm-&gt;h[<span class="number">4</span>] ^= E; sm-&gt;h[<span class="number">5</span>] ^= F; sm-&gt;h[<span class="number">6</span>] ^= G; sm-&gt;h[<span class="number">7</span>] ^= H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成杂凑值函数"><a href="#生成杂凑值函数" class="headerlink" title="生成杂凑值函数"></a><font size = 3>生成杂凑值函数</font></h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//生成杂凑值函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm3_final</span><span class="params">(sm3 *sm,<span class="keyword">unsigned</span> <span class="keyword">char</span> h[<span class="number">32</span>])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">unsign32 len0 = sm-&gt;length[<span class="number">0</span>];</span><br><span class="line">unsign32 len1 = sm-&gt;length[<span class="number">1</span>];</span><br><span class="line">sm3_process(sm, pad);</span><br><span class="line"><span class="keyword">while</span> (sm-&gt;length[<span class="number">0</span>] % <span class="number">512</span> != <span class="number">448</span>) &#123;</span><br><span class="line">sm3_process(sm, zero);</span><br><span class="line">&#125;</span><br><span class="line">sm-&gt;w0[<span class="number">14</span>] = len1;</span><br><span class="line">sm-&gt;w0[<span class="number">15</span>] = len0;</span><br><span class="line">sm3_transform(sm);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">h[i] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((sm-&gt;h[i / <span class="number">4</span>] &gt;&gt; (<span class="number">8</span> * (<span class="number">3</span> - i % <span class="number">4</span>))) &amp; <span class="number">0xff</span>L);</span><br><span class="line">&#125;</span><br><span class="line">sm3_init(sm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口封装函数"><a href="#接口封装函数" class="headerlink" title="接口封装函数"></a><font size = 3>接口封装函数</font></h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口封装</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm3_hash</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *test)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">sm3 sm;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> h[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">sm3_init(&amp;sm);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; test[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">sm3_process(&amp;sm, test[i]);</span><br><span class="line">&#125;</span><br><span class="line">sm3_final(&amp;sm, h);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)h[i]);</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体使用例子"><a href="#具体使用例子" class="headerlink" title="具体使用例子"></a><font size = 3>具体使用例子</font></h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> test[] = <span class="string">"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd"</span>;</span><br><span class="line">sm3_hash(test);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

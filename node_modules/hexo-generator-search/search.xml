<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java编程思想——第五章(初始化与清理)</title>
      <link href="/2020/03/30/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0(%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86)/"/>
      <url>/2020/03/30/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0(%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第五章(初始化与清理)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。</p></blockquote><h3 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h3><ul><li>调用构造器是编译器的责任。</li><li>构造器采用与<strong>类相同</strong>的名称。</li><li>在Java中，<font><strong>“初始化”和“创建”</strong></font>捆绑在一起，两者不能分离。</li><li>构造器是一种特殊类型的方法，没有返回值，与返回值为空（void）不同。</li></ul><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><h4 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h4><ul><li>参数类型的差异</li><li>参数顺序的差异 (一般情况<strong>不建议</strong>，因为这会使代码难以维护）</li></ul><h4 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h4><ul><li>实参类型<strong>小于</strong>形参类型，实际数据类型会被提升。<br>无法找到接受char参数的方法时，char直接提升至int型。</li><li>实参类型<strong>大于</strong>形参类型，需通过类型转换来执行<strong>窄化转换</strong>，否则编译器会报错。</li></ul><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><blockquote><p>问题：<strong>a.peel(1),b.peel(2)</strong>，如何知道是a还是b调用的peel方法?<br>答案：使用this关键字，this可理解为所操作<strong>对象的引用</strong>，作为第一个参数传给peel()，类似于<strong>Banna.peel(a,1)</strong></p></blockquote><h3 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h3><ul><li>必须将构造器调用置于最起始处。</li><li>构造器中只能用this调用一个构造器</li><li>除构造器外，编译器禁止在其他任何方法中调用构造器。</li></ul><h3 id="static的含义"><a href="#static的含义" class="headerlink" title="static的含义"></a>static的含义</h3><p>static方法没有this的方法，因为在<strong>static方法的内部不能调用非静态方法。</strong></p><h3 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h3><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><ul><li><p>只能释放由<strong>new分配</strong>的内存</p></li><li><p>无法释放由并非new创建的对象所占据的内存，以及“本地方法”分配的内存。</p><pre><code>本地方法：在Java中调用了非Java代码，如C的malloc()会分配存储空间</code></pre></li></ul><h4 id="finalize-原理"><a href="#finalize-原理" class="headerlink" title="finalize()原理"></a>finalize()原理</h4><ul><li><p>垃圾回收器追备好释放对象占用的存储空间时，首先调用finalize()，然后垃圾回收动作发生，便会真正地回收对象占用的内存。</p></li><li><p>C++中，对象一定会被销毁，而Java里的对象却<strong>并非总是被垃圾回收</strong></p><ol><li>对象可能不被垃圾回收</li><li>垃圾回收并不等于“析构”</li><li>垃圾回收只与内存有关</li><li>绝对不能直接调用<strong>finalize()</strong></li></ol></li></ul><pre><code>System.gc()用于强制进行终结动作</code></pre><h4 id="垃圾回收器如何工作"><a href="#垃圾回收器如何工作" class="headerlink" title="垃圾回收器如何工作"></a>垃圾回收器如何工作</h4><ul><li><p>垃圾回收器显著提升对象的创建速度——<strong>存储空间的释放会影响存储空间的分配</strong>（Java虚拟机的工作方式）</p></li><li><p><strong>Java虚拟机中的堆的实现</strong>：像是一个<strong>传送带</strong>，每分配一个新对象，它就往前移动一格。（这意味着对象存储空间的分配速度非常快）</p></li><li><p><strong>垃圾回收器工作原理</strong>：一面回收空间，一面使堆中的对象紧凑排列，这样“<strong>堆指针</strong>”就可以很容易移动至更靠近传送带的开始处，也就尽量<strong>避免了页面错误</strong>。通过垃圾回收器对对象重新排列，实现了<strong>一种高速的、有无限空间可分配的堆模型</strong>。</p></li><li><p>Java虚拟机采用自适应的垃圾回收技术</p><ol><li>第一种做法：<strong>停止——复制(stop-and-copy)</strong>：先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。当对象被复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列，然后就可以同上述的方法简单而直接地分配新空间。<br>这种方法效率会降低，<strong>两个原因</strong><br><font><strong>1）</strong></font>需要<strong>两个堆</strong>，从而使得维护比实际需要多一倍的空间，某些Java虚拟机处理方式：从<strong>堆中分配几块较大的内存</strong>，复制动作发生在这些<strong>大块内存之间</strong>。<br><font><strong>2）</strong></font>程序中可能只有少量垃圾，甚至没有垃圾，这进行复制就造成了<strong>浪费</strong>。于是Java虚拟机进行检查，如果没有新垃圾产生，就会转换到另一种工作模式（根据情况转变即“自适应”），被称为<strong>标记——清扫(make-and-sweep)</strong></li><li>第二种做法：<strong>标记——清扫</strong>,从<strong>堆栈</strong>和<strong>静态存储区</strong>出发，遍历所有的引用，进而找出所有存活的对象，每找到一个，便会给对象一个标记。完成所有标记工作之后，便开始清理动作，没有标记的对象会被释放，不会发生任何复制动作，<strong>同时剩下的堆空间是不连续的</strong>。</li></ol><blockquote><p>“停止——复制”不在后台进行，而“标记——清扫”必须在程序暂停的情况下进行。</p></blockquote><blockquote><p>内存分配以较大的“块”为单位，如果对象较大，它会占用单独的块，每个块会用相应的代数来记录它是否存活（这对处理大量短命的临时对象很有帮助）。Java虚拟机会监视，如果对象稳定，效率降低，便会切换到“标记——清扫”方式；如果堆空间出现很多碎片，就会切换到“停止——复制”方式，<strong>这便是“自适应”技术，全称：“自适应的、分代的，停止——复制、标记——清扫”式垃圾回收器</strong>。</p></blockquote></li><li><p>Java虚拟机中有许多附加技术用以提升速度。尤其是与加载器操作有关的，<strong>称为“即时”（JIT，Just-In-Time）编译器技术</strong>。<br>这种技术可以把程序全部或部分翻译成<strong>本地机器码（本是Java虚拟机的工作）</strong>，从而使程序运行速度得到提升。</p></li></ul><p>当装载某个类时，编译器会先找到.class文件，将该类的<strong>字节码装入内存</strong>。<br>此时，有<strong>两个方案</strong>可以选择：<br><font><strong>1)</strong></font>让即时编译器编译所有代码，这做法存在两个<strong>缺陷</strong>：</p><ol><li>加载动作散落在整个程序生命周期内，累加起来要花更多时间。</li><li>增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这导致<strong>页面调度</strong>，从而降低程序速度。</li></ol><p><font><strong>2)</strong></font><strong>惰性评估(lazy evaluation)</strong>，即时编译器只在必要的情况进行编译代码，从而使不会被执行的代码不会被JIT编译。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>只有第一次访问静态数据时，静态对象才会被初始化</li><li>初始化顺序：<ol><li>静态初始化 static{},首次加载类时执行（即便未生成类对象）</li><li>非静态初始化 {}，生成对象时执行，匿名内部类的初始化（见第十章）</li><li>构造器</li></ol></li></ul><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1;</span><br><span class="line"><span class="keyword">int</span> a1[];</span><br></pre></td></tr></table></figure><p>在Java中<strong>前一种格式更合理</strong>，表明了一个int型数组。</p><ul><li><p>数组的初始化可以由一对花括号括起来的值组成的，其存储空间的分配等价于使用new，由编译器负责。<br><code>int[] a1 = {1,2,3,4,5};</code><br>所有数组都一个<strong>固有成员length</strong>，可以通过它获知数组内包含了多少个元素。</p><blockquote><p>每次访问数组的时候都要检查边界，这一做法在时间和代码上都是需要开销的，无法禁用这个功能。Java设计者认为这种权衡是值得的。尽管你可能会受到诱惑，去编写你认为可以使得数组访问效率提高的代码，但是这一切都是在浪费时间，因为自动的编译期错误和运行时优化都可以提高数组访问的速度。</p></blockquote></li><li><p>数组能够在定义的同时进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">10</span>)];</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#125;;</span><br></pre></td></tr></table></figure><p>初始化列表的最后一个逗号是可选的，这特性使得维护长列表变得更加容易。<br>若创建一个非基本类型的数组，那么就创建了一个<strong>引用数组</strong>（例如Integer是一个类而不是基本类型）</p></li><li><p>可变参数列表，应用于参数个数或类型未知的场合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">(Object... args)</span></span>&#123;&#125;</span><br><span class="line">p(<span class="keyword">new</span> Integer(<span class="number">47</span>),<span class="keyword">new</span> Float(<span class="number">3.14</span>),<span class="keyword">new</span> Double(<span class="number">11.11</span>));</span><br><span class="line">p(<span class="number">47</span>,<span class="number">3.14F</span>,<span class="number">11.11</span>);</span><br><span class="line">p(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>);</span><br><span class="line">p((Object[])<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">p();<span class="comment">//空参数也可以</span></span><br></pre></td></tr></table></figure><p><strong>应该在重载方法的最多一个版本上使用可变参数列表，或者根本不用。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第四章(控制执行流程)</title>
      <link href="/2020/03/26/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B)/"/>
      <url>/2020/03/26/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第四章(控制执行流程)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在Java中，你要使用<strong>执行控制语句</strong>来做出选择。</p></blockquote><blockquote><p>Java并不支持goto语句（该语句引起许多反对意见，但它仍是解决某些特殊问题的最便利的方法）。在Java中，仍然可以进行类似goto那样的跳转，但比起典型的goto，有了很多限制。</p></blockquote><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在一个控制表达式中，<strong>定义多个变量</strong>的这种能力<strong>只限于for循环适用</strong>，在其他任何选择或迭代语句中都不能适用这种方式。</p><h3 id="Foreach语法"><a href="#Foreach语法" class="headerlink" title="Foreach语法"></a>Foreach语法</h3><p><code>for(float x : f){}</code></p><p>这条语句定义了一个float类型的变量x,继而将每一个f的元素赋值给x。<br>foreach 可用于任何<strong>Iterable对象</strong>。</p><p>例子，<strong>String</strong>类有一个方法<strong>toCharArray()</strong>，它返回一个<strong>char数组</strong>，可以轻易迭代出字符串里面的所有字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachString</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c: <span class="string">"An African Swallow"</span>.toCharArray())</span><br><span class="line">System.out.print(c + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">A n  A f r i c a n  S w a l l o w</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch要求使用一个<strong>选择因子</strong>，并且必须是<strong>int或char</strong>那样的<strong>整数值</strong>。</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p><strong>用途</strong></p><ul><li>指定一个方法返回什么值（假设没有void返回值）</li><li>会导致当前的方法退出，并返回那个值。</li></ul><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><ul><li>break：强行退出循环，不执行循环中剩余的语句。</li><li>continue：停止当前的迭代，退回至循环起始处，开始下一次迭代。</li></ul><h3 id="臭名昭著的goto"><a href="#臭名昭著的goto" class="headerlink" title="臭名昭著的goto"></a>臭名昭著的goto</h3><blockquote><p>Java编译器生成它自己的“汇编代码”，但是这个代码是运行在<strong>Java虚拟机</strong>上的，而不是直接运行在CPU硬件上。</p></blockquote><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>标签需恰好出现在<strong>迭代语句之前</strong>。</p><blockquote><p>Java里需要使用标签的唯一理由就是因为有<strong>循环嵌套存在</strong>，而且想从多层嵌套中break或continue。通过限制语句的能力，反而能使一项语言特性更加有用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第三章(操作符)</title>
      <link href="/2020/03/25/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0(%E6%93%8D%E4%BD%9C%E7%AC%A6)/"/>
      <url>/2020/03/25/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0(%E6%93%8D%E4%BD%9C%E7%AC%A6)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第三章(操作符)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>在最底层，<strong>Java中的数据是通过使用操作符</strong>来操作的。</p></blockquote><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><pre><code>在为对象赋值时，实际上是把引用从一个地方复制到另一个地方假设对对象c、d使用c = d,那么c和d都将指向原来只有d指向的那个对象。</code></pre><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equivalence</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">47</span>;</span><br><span class="line"><span class="comment">//System.out.println(equals(n1,n2));</span></span><br><span class="line">System.out.println(n1 != n2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment"> * false</span></span><br><span class="line"><span class="comment"> * true</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>尽管对象的内容相同，然而对象的引用确实不同的，而==和!=比较的就是<strong>对象的引用</strong>。<br>比较对象的实际内容是否相同，需使用特殊方法<strong>equals()</strong>，但是基本类型直接使用==和!=即可，<strong>基本类型不适用与equals()</strong>。</p><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><strong>短路</strong>：一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。<br><code>test1(0) &amp;&amp; test2(2) &amp;&amp; test3(2)</code></p><p>当test(0)的结果为false，即可判断出这个式子的结果为false，所以余下的test2(2)和test3(2)均不会计算。</p><pre><code>事实上，如果所有的逻辑表达式都有一部分不必计算，那将获得潜在的性能提升。</code></pre><h3 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h3><p>通过使用Integer和Long类的静态方法<font><strong>toBinaryString()</strong></font>可以容易实现将<strong>十六进制</strong>和<strong>八进制</strong>数字以<strong>二进制</strong>形式显示。</p><h3 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h3><blockquote><p>按位操作符来源于<strong>C语言面向底层</strong>的操作，在这种操作中经常需要直接操纵硬件，设置<strong>硬件寄存器内的二进制位</strong>，而Java的设计初衷是<strong>嵌入电视机机顶盒</strong>，于是这种面向底层的操作仍被保留了下来。</p></blockquote><h3 id="类型转换操作符"><a href="#类型转换操作符" class="headerlink" title="类型转换操作符"></a>类型转换操作符</h3><p>通常，表达式中出现的<strong>最大的数据类型</strong>决定了表达式最终结果的数据类型.</p><blockquote><p>如果将一个Float值与一个double值想成，结果就是<strong>double</strong>；如果将一个int和一个long值相加，则结果为<strong>long</strong>。</p></blockquote><h3 id="Java没有sizeof"><a href="#Java没有sizeof" class="headerlink" title="Java没有sizeof"></a>Java没有sizeof</h3><p>C和C++中，sizeof()操作符可以告诉你为数据项分配的字节数，使用sizeof()的最大原因是为了“移植”，因为<strong>不同的数据类型在不同的机器上可能有不同的大小。</strong><br>Java不需要sizeof()，因为所有数据类型在<strong>所有机器中的大小都是相同的</strong>，它已经被设计在语言中了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第二章(一切都是对象)</title>
      <link href="/2020/03/24/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0(%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1)/"/>
      <url>/2020/03/24/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0(%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第二章(一切都是对象)的概括总结</p></blockquote><a id="more"></a><hr><blockquote><p>尽管Java是基于C++的，但是相比之下，Java是一种更“纯粹”的面向对象程序设计语言。<br>在开始用Java进行设计之前，必须将思想转化到面向对象的世界中来。<br><strong>虽然Java中（几乎）一切都是对象，但是Java仍然存在不属于对象的东西。</strong></p></blockquote><h3 id="用引用操作对象"><a href="#用引用操作对象" class="headerlink" title="用引用操作对象"></a>用引用操作对象</h3><p>使用<font><strong>引用(reference)</strong></font>来进行操作对象</p><pre><code>类比于遥控器（引用）——&gt; 电视机（对象）</code></pre><p>通常，必须对对象采用一种更通用的初始化方法，而Java中字符串可以用<strong>带引号的文本初始化</strong>。</p><h3 id="必须有你创建所有对象"><a href="#必须有你创建所有对象" class="headerlink" title="必须有你创建所有对象"></a>必须有你创建所有对象</h3><h4 id="数据存储区域"><a href="#数据存储区域" class="headerlink" title="数据存储区域"></a>数据存储区域</h4><ul><li>寄存器：最快的存储区，位于处理器内部。Java中不能直接控制，也不能在程序中感受到寄存器存在的任何迹象（C和C++允许向编译器简易寄存器的分配方式）</li><li>堆栈：速度仅次于寄存器，位于通用RAM（随机访问存储器），对象引用存储其中。</li><li>堆：通用内存池，存放对象。</li><li>常量存储：存放在程序代码内部；在嵌入式系统中，存在放在ROM（只读存储器）。</li><li>非RAM存储：流对象和持久化对象。</li></ul><h4 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h4><p>不用<strong>new</strong>创建变量，而是创建一个并非是引用的自动变量<br>这个变量直接存储“值”，并置于<strong>堆栈</strong>中，更加高效。</p><p><img src="https://s1.ax1x.com/2020/03/24/8bzjnx.png" alt="" title="基本类型"></p><h4 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h4><p><strong>BigInteger</strong>和<strong>BigDecimal</strong>，大体属于“包装器类”的范畴，但没有对应的基本类型。<br>这两类变量需使用方法调用来代替运算符。</p><pre><code>BIgInteger支持任意精度的整数BigDecimal支持任意精度的定点数。</code></pre><h3 id="Java中的数组"><a href="#Java中的数组" class="headerlink" title="Java中的数组"></a>Java中的数组</h3><blockquote><p><strong>基本数据类型的数组会被初始化</strong>。<br>Java的主要目标之一是<strong>安全性</strong>，数组会确保初始化，而且不能在它的范围之外被访问。由此的范围检查，换来了安全性和效率的提高，必须以<strong>每个数组上少量的内存开销及运行时的下标检查为代价的</strong>。（Java有时可以优化这些操作）</p></blockquote><h3 id="永远不需要销毁对象"><a href="#永远不需要销毁对象" class="headerlink" title="永远不需要销毁对象"></a>永远不需要销毁对象</h3><p>基本类型变量的<font><strong>作用域(scope)</strong></font>由花括号的位置决定（C、C++、Java）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">96</span>;<span class="comment">// Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译器将会报告变量x已经定义过。所以，在C和C++里将一个较大作用域的变量“隐藏”起来的做法，在Java里是不允许的。因为Java设计者认为这样做会导致程序混乱。</p></blockquote><hr><p><strong>对象不具备生命周期</strong>，用new创建一个Java对象时，它能够存活于作用域之外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String  s = <span class="keyword">new</span> String(<span class="string">"a string"</span>);</span><br><span class="line">&#125; <span class="comment">// End of scope</span></span><br></pre></td></tr></table></figure><blockquote><p>其中引用s在作用域终点便消失了，但是s指向的String对象扔继续占据内存空间。<br>Java有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象，随后，释放这些对象的内存空间，以便供其他新对象使用。这样做就消除了“<strong>内存泄漏</strong>”，这类问题是程序员忘记释放内存而产生的。</p></blockquote><h3 id="创建新的数据类型：类"><a href="#创建新的数据类型：类" class="headerlink" title="创建新的数据类型：类"></a>创建新的数据类型：类</h3><p>属于<strong>基本数据类型的数据成员</strong>会被初始化。<br><strong>非某个类</strong>的字段不会被初始。</p><pre><code>（Java编译会因这类变量没有初始化而返回错误）</code></pre><h3 id="构建一个Java程序"><a href="#构建一个Java程序" class="headerlink" title="构建一个Java程序"></a>构建一个Java程序</h3><p><strong>static关键字</strong>可以满足两方面的需要</p><ul><li>只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。</li><li>希望某个方法不与包含它的类的任何对象关联在一起。即没有创建对象，也能够调用这个方法。</li></ul><h3 id="注释和嵌入式文档"><a href="#注释和嵌入式文档" class="headerlink" title="注释和嵌入式文档"></a>注释和嵌入式文档</h3><p>javadoc命令在“/<em>*”注释中出现，结束于“</em>/”<br>javadoc只能为public、protected注释</p><pre><code>可用-private进行标记，对private成员添加注释</code></pre><p><strong>标签示例</strong></p><ul><li>@see：引用其他类</li><li>{@link package.class#member}：使用行内label作为超链接文本</li><li>{@docRoot}：产生到文档根目录的相对路径，用于文档树页面的显式超链接</li><li>{@inheritDoc}：从当前类的最直接的基类中继承相关文档到当前文档注释中</li><li>@version：显示包含在版本说明中的重要信息</li><li>@author：显示你的姓名或任何合适的信息</li><li>@since：允许指定程序代码最早使用的版本</li><li>@param：方法的参数列表中的标识符 + 可延续数行的文本<br><code>@param parameter-name description</code></li><li>@return：描述返回值的含义</li><li>@throws：一个异常类的无歧义的名字 + 可延续数行的文本<br><code>@throws fully-qualified-class-name description</code></li></ul><h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>采用“<strong>驼峰风格</strong>”：类名内部单词首字母大写，而其他内容标识符第一个字母小写。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第一章(对象导论)</title>
      <link href="/2020/03/21/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0(%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA)/"/>
      <url>/2020/03/21/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0(%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第一章(对象导论)的概括总结</p></blockquote><a id="more"></a><hr><h3 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h3><p><strong>汇编语言</strong>：底层机器的轻微抽象。<br><strong>“命令式”语言</strong>：汇编语言的抽象。所作的主要抽象在解决问题基于计算机的结构，而不是基于所要解决的问题的结构。</p><p><strong>只针对待解问题建模</strong>：</p><p>1、早期的编程语言-<strong>LISP</strong>和<strong>APL</strong>，它们选择考虑世界的某些特定视图。</p><ul><li>LISP-所有问题最终都是列表；APL-所有问题都是算法形式的。</li><li>但是他们无法解决超期特定领域的问题。</li></ul><p>2、面向对象方式（OOP），对象即问题空间中的元素，不会受限于任何特定类型的问题。</p><p>第一个成功的OOP语言的五个基本特性：<br>1、万物皆为对象。<br>2、程序是对象的结合，它们通过发送消息来告知彼此所要做的。<br>3、每个对象都有自己的由其他对象所构成的存储。<br>4、每个对象都拥有其类型。<br>5、某一特定类型的所有对象都可以接受同样的消息。</p><hr><h3 id="每个对象都一个接口"><a href="#每个对象都一个接口" class="headerlink" title="每个对象都一个接口"></a>每个对象都一个接口</h3><p><strong>类</strong>：问题空间的元素&lt;—&gt;解空间的对象，即它们之间的映射。<br><strong>接口</strong>：确定对某一特定对象所能发出的请求。</p><hr><h3 id="每个对象都提供服务"><a href="#每个对象都提供服务" class="headerlink" title="每个对象都提供服务"></a>每个对象都提供服务</h3><p>将对象想象为<strong>服务提供者</strong><br>1、用户正在使用程序提供的服务，而程序在通过调用其他对象提供的服务来实现程序服务供应。<br>2、有助于提高对象的<strong>内聚性</strong>，即对象不试图做更多的事。</p><hr><h3 id="被隐藏的具体实现"><a href="#被隐藏的具体实现" class="headerlink" title="被隐藏的具体实现"></a>被隐藏的具体实现</h3><p>开发人员可分为<strong>类创建者</strong>和<strong>客户端程序员</strong></p><ul><li>类创建者可类比为Java语言库开发者</li><li>客户端程序员则是有我这样的入门程序猿。</li></ul><hr><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>设置访问控制的<strong>原因</strong>有</p><ul><li>让客户端程序员无法触及他们不应该触及的部分。</li><li>允许库设计者可以改变类内部的工作方式而不影响到客户端程序员。</li></ul><p><strong>关键字</strong></p><ul><li><strong>public</strong>：所有人都可以访问</li><li><strong>private</strong>：只有自己可以访问</li><li><strong>protected</strong>：继承的类可访问</li><li><strong>default</strong>：同一个包内可访问</li></ul><hr><h3 id="复用具体实现"><a href="#复用具体实现" class="headerlink" title="复用具体实现"></a>复用具体实现</h3><p><strong>组合</strong>：使用现有的类合成新的类，新类的成员对象通常被声明为private，具有灵活性。<br><strong>继承</strong>：不具备组合的灵活性，编译器会对继承类施加编译时的限制。</p><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>基类和导出类之间的<strong>差异</strong>在于：</p><ul><li>导出类可拥有新方法。</li><li>导出类可覆盖基类的方法。</li></ul><hr><h3 id="伴随多态的可互换对象"><a href="#伴随多态的可互换对象" class="headerlink" title="伴随多态的可互换对象"></a>伴随多态的可互换对象</h3><blockquote><p>处理层次结构时，将对象当做基类对待而不是特定类型，例如关心几何形状的特性：都可以被绘制、擦除和移动，因为几何形状能做的，圆形、正方形、三角形都可以实现。</p></blockquote><p><strong>函数调用</strong>分为两种</p><ul><li><strong>前期绑定</strong>，这属于非面向对象编程，它运行代码的绝对地址。</li><li><strong>后期绑定</strong>，这属于OOP，编译器会确保调用方法的存在，来计算代码的地址。Java为实现后期绑定，使用了一段特殊的代码在对象中存储的信息来计算方法体的地址。<blockquote><p>C++中使用virtual关键字实现动态绑定，而Java中是默认的。</p></blockquote></li></ul><p><strong>向上转型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Shape shape)</span></span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br><span class="line">Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">doSomething(circle);</span><br></pre></td></tr></table></figure><p>其中<strong>Shape</strong>是基类，而<strong>Circle</strong>是继承类，最终代码会调用<strong>Circle</strong>的<strong>draw</strong>方法，程序在运行中得知<strong>Circle</strong>是一个<strong>Shape</strong>，并且知道调用<strong>Circle</strong>中的<strong>draw</strong>方法而不是直接调用<strong>Shape</strong>的<strong>draw</strong>方法。</p><blockquote><p>这就是多态的神奇之处。</p></blockquote><hr><h3 id="单根继承结构"><a href="#单根继承结构" class="headerlink" title="单根继承结构"></a>单根继承结构</h3><blockquote><p>所有OOP语言都拥有一个最终基类（所有类都继承的类），在Java中为Object。</p></blockquote><p>这一结构有许多<strong>好处</strong></p><ul><li>保证所有对象具有某些功能</li><li>极大简化参数传递</li><li>容易实现垃圾回收</li></ul><hr><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><blockquote><p><strong>Java</strong>中的容器有许多，例如：<strong>List</strong>、<strong>Map</strong>、<strong>Set</strong>。</p></blockquote><p>设置不同的容器有两个<strong>原因</strong></p><ul><li>不同容器提供了不同类型的接口和外部行为</li><li>不同容器对于某些操作具有不同的效率，ArrayList和LinkedList在访问数据和插入数据有着天壤地别的效率差距。</li></ul><p><strong>向下转型</strong>：从<strong>Object</strong>转变成具体类型。</p><p>参数化类型（范型）<br>可以使用下面语句来创建一个存储Shape的ArrayList<br><code>ArrayList&lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;();</code></p><hr><h3 id="对象的创建和生命期"><a href="#对象的创建和生命期" class="headerlink" title="对象的创建和生命期"></a>对象的创建和生命期</h3><p><font><strong>C++</strong></font><br>为了追求最大的执行速度，在编写时确定了存储空间、生命周期.<br>存储空间为<strong>堆栈</strong>和<strong>静态存储区</strong>，但是这样牺牲了灵活性。</p><p><strong>Java</strong><br>采用了动态内存分配方式，对象存放在<strong>堆的内存池</strong>中。</p><blockquote><p>动态方式存在一个逻辑假设：对象趋向于变得十分复杂，所以查找和释放存储空间的开销在对象的创建面前影响很小。</p></blockquote><hr><h3 id="异常处理：处理错误"><a href="#异常处理：处理错误" class="headerlink" title="异常处理：处理错误"></a>异常处理：处理错误</h3><p>异常处理将错误处理置于编程语言中，甚至置于操作系统中。<br><strong>Java</strong>内置异常处理，并且<strong>强制使用</strong>。</p><blockquote><p>异常处理在非面向对象语言中就已经存在。</p></blockquote><hr><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>多个并发任务访问同一项资源，需使用<strong>线程锁</strong>来解决问题。<br><strong>Java</strong>的并发是内置的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(C)实现SM4国密算法</title>
      <link href="/2020/03/16/%5BC%5D%E5%AE%9E%E7%8E%B0sm4%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/16/%5BC%5D%E5%AE%9E%E7%8E%B0sm4%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于上篇<strong>SM3国密算法</strong>改编而成。</p></blockquote><a id="more"></a><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>全称：“SM4分组密码算法”，其中sm是<strong>商用密码</strong>的拼音简称。</p><p> 以下是算法文字说明<br> 大致思想与AES-128一致</p></li></ul><h2 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h2><p><img src="https://s1.ax1x.com/2020/03/16/8GgZYn.jpg" alt="" title="说明1"></p><hr><p><img src="https://s1.ax1x.com/2020/03/16/8GgeWq.jpg" alt="" title="说明2"></p><hr><p><img src="https://s1.ax1x.com/2020/03/16/8GgnS0.jpg" alt="" title="说明3"></p><hr><p><img src="https://s1.ax1x.com/2020/03/16/8GgKyT.jpg" alt="" title="说明4"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font size = 3>定义</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义无符号整型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsign32 unsigned int</span></span><br><span class="line"><span class="comment">//定义sm3结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">unsign32 k[<span class="number">40</span>];</span><br><span class="line">unsign32 rk[<span class="number">40</span>];</span><br><span class="line">unsign32 x[<span class="number">40</span>];</span><br><span class="line">unsign32 h[<span class="number">4</span>];</span><br><span class="line">&#125; sm4;</span><br><span class="line"></span><br><span class="line"><span class="comment">//S盒 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Sbox[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x90</span>,<span class="number">0xe9</span>,<span class="number">0xfe</span>,<span class="number">0xcc</span>,<span class="number">0xe1</span>,<span class="number">0x3d</span>,<span class="number">0xb7</span>,<span class="number">0x16</span>,<span class="number">0xb6</span>,<span class="number">0x14</span>,<span class="number">0xc2</span>,<span class="number">0x28</span>,<span class="number">0xfb</span>,<span class="number">0x2c</span>,<span class="number">0x05</span>,</span><br><span class="line"><span class="number">0x2b</span>,<span class="number">0x67</span>,<span class="number">0x9a</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0xbe</span>,<span class="number">0x04</span>,<span class="number">0xc3</span>,<span class="number">0xaa</span>,<span class="number">0x44</span>,<span class="number">0x13</span>,<span class="number">0x26</span>,<span class="number">0x49</span>,<span class="number">0x86</span>,<span class="number">0x06</span>,<span class="number">0x99</span>,</span><br><span class="line"><span class="number">0x9c</span>,<span class="number">0x42</span>,<span class="number">0x50</span>,<span class="number">0xf4</span>,<span class="number">0x91</span>,<span class="number">0xef</span>,<span class="number">0x98</span>,<span class="number">0x7a</span>,<span class="number">0x33</span>,<span class="number">0x54</span>,<span class="number">0x0b</span>,<span class="number">0x43</span>,<span class="number">0xed</span>,<span class="number">0xcf</span>,<span class="number">0xac</span>,<span class="number">0x62</span>,</span><br><span class="line"><span class="number">0xe4</span>,<span class="number">0xb3</span>,<span class="number">0x1c</span>,<span class="number">0xa9</span>,<span class="number">0xc9</span>,<span class="number">0x08</span>,<span class="number">0xe8</span>,<span class="number">0x95</span>,<span class="number">0x80</span>,<span class="number">0xdf</span>,<span class="number">0x94</span>,<span class="number">0xfa</span>,<span class="number">0x75</span>,<span class="number">0x8f</span>,<span class="number">0x3f</span>,<span class="number">0xa6</span>,</span><br><span class="line"><span class="number">0x47</span>,<span class="number">0x07</span>,<span class="number">0xa7</span>,<span class="number">0xfc</span>,<span class="number">0xf3</span>,<span class="number">0x73</span>,<span class="number">0x17</span>,<span class="number">0xba</span>,<span class="number">0x83</span>,<span class="number">0x59</span>,<span class="number">0x3c</span>,<span class="number">0x19</span>,<span class="number">0xe6</span>,<span class="number">0x85</span>,<span class="number">0x4f</span>,<span class="number">0xa8</span>,</span><br><span class="line"><span class="number">0x68</span>,<span class="number">0x6b</span>,<span class="number">0x81</span>,<span class="number">0xb2</span>,<span class="number">0x71</span>,<span class="number">0x64</span>,<span class="number">0xda</span>,<span class="number">0x8b</span>,<span class="number">0xf8</span>,<span class="number">0xeb</span>,<span class="number">0x0f</span>,<span class="number">0x4b</span>,<span class="number">0x70</span>,<span class="number">0x56</span>,<span class="number">0x9d</span>,<span class="number">0x35</span>,</span><br><span class="line"><span class="number">0x1e</span>,<span class="number">0x24</span>,<span class="number">0x0e</span>,<span class="number">0x5e</span>,<span class="number">0x63</span>,<span class="number">0x58</span>,<span class="number">0xd1</span>,<span class="number">0xa2</span>,<span class="number">0x25</span>,<span class="number">0x22</span>,<span class="number">0x7c</span>,<span class="number">0x3b</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x78</span>,<span class="number">0x87</span>,</span><br><span class="line"><span class="number">0xd4</span>,<span class="number">0x00</span>,<span class="number">0x46</span>,<span class="number">0x57</span>,<span class="number">0x9f</span>,<span class="number">0xd3</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,<span class="number">0x4c</span>,<span class="number">0x36</span>,<span class="number">0x02</span>,<span class="number">0xe7</span>,<span class="number">0xa0</span>,<span class="number">0xc4</span>,<span class="number">0xc8</span>,<span class="number">0x9e</span>,</span><br><span class="line"><span class="number">0xea</span>,<span class="number">0xbf</span>,<span class="number">0x8a</span>,<span class="number">0xd2</span>,<span class="number">0x40</span>,<span class="number">0xc7</span>,<span class="number">0x38</span>,<span class="number">0xb5</span>,<span class="number">0xa3</span>,<span class="number">0xf7</span>,<span class="number">0xf2</span>,<span class="number">0xce</span>,<span class="number">0xf9</span>,<span class="number">0x61</span>,<span class="number">0x15</span>,<span class="number">0xa1</span>,</span><br><span class="line"><span class="number">0xe0</span>,<span class="number">0xae</span>,<span class="number">0x5d</span>,<span class="number">0xa4</span>,<span class="number">0x9b</span>,<span class="number">0x34</span>,<span class="number">0x1a</span>,<span class="number">0x55</span>,<span class="number">0xad</span>,<span class="number">0x93</span>,<span class="number">0x32</span>,<span class="number">0x30</span>,<span class="number">0xf5</span>,<span class="number">0x8c</span>,<span class="number">0xb1</span>,<span class="number">0xe3</span>,</span><br><span class="line"><span class="number">0x1d</span>,<span class="number">0xf6</span>,<span class="number">0xe2</span>,<span class="number">0x2e</span>,<span class="number">0x82</span>,<span class="number">0x66</span>,<span class="number">0xca</span>,<span class="number">0x60</span>,<span class="number">0xc0</span>,<span class="number">0x29</span>,<span class="number">0x23</span>,<span class="number">0xab</span>,<span class="number">0x0d</span>,<span class="number">0x53</span>,<span class="number">0x4e</span>,<span class="number">0x6f</span>,</span><br><span class="line"><span class="number">0xd5</span>,<span class="number">0xdb</span>,<span class="number">0x37</span>,<span class="number">0x45</span>,<span class="number">0xde</span>,<span class="number">0xfd</span>,<span class="number">0x8e</span>,<span class="number">0x2f</span>,<span class="number">0x03</span>,<span class="number">0xff</span>,<span class="number">0x6a</span>,<span class="number">0x72</span>,<span class="number">0x6d</span>,<span class="number">0x6c</span>,<span class="number">0x5b</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x8d</span>,<span class="number">0x1b</span>,<span class="number">0xaf</span>,<span class="number">0x92</span>,<span class="number">0xbb</span>,<span class="number">0xdd</span>,<span class="number">0xbc</span>,<span class="number">0x7f</span>,<span class="number">0x11</span>,<span class="number">0xd9</span>,<span class="number">0x5c</span>,<span class="number">0x41</span>,<span class="number">0x1f</span>,<span class="number">0x10</span>,<span class="number">0x5a</span>,<span class="number">0xd8</span>,</span><br><span class="line"><span class="number">0x0a</span>,<span class="number">0xc1</span>,<span class="number">0x31</span>,<span class="number">0x88</span>,<span class="number">0xa5</span>,<span class="number">0xcd</span>,<span class="number">0x7b</span>,<span class="number">0xbd</span>,<span class="number">0x2d</span>,<span class="number">0x74</span>,<span class="number">0xd0</span>,<span class="number">0x12</span>,<span class="number">0xb8</span>,<span class="number">0xe5</span>,<span class="number">0xb4</span>,<span class="number">0xb0</span>,</span><br><span class="line"><span class="number">0x89</span>,<span class="number">0x69</span>,<span class="number">0x97</span>,<span class="number">0x4a</span>,<span class="number">0x0c</span>,<span class="number">0x96</span>,<span class="number">0x77</span>,<span class="number">0x7e</span>,<span class="number">0x65</span>,<span class="number">0xb9</span>,<span class="number">0xf1</span>,<span class="number">0x09</span>,<span class="number">0xc5</span>,<span class="number">0x6e</span>,<span class="number">0xc6</span>,<span class="number">0x84</span>,</span><br><span class="line"><span class="number">0x18</span>,<span class="number">0xf0</span>,<span class="number">0x7d</span>,<span class="number">0xec</span>,<span class="number">0x3a</span>,<span class="number">0xdc</span>,<span class="number">0x4d</span>,<span class="number">0x20</span>,<span class="number">0x79</span>,<span class="number">0xee</span>,<span class="number">0x5f</span>,<span class="number">0x3e</span>,<span class="number">0xd7</span>,<span class="number">0xcb</span>,<span class="number">0x39</span>,<span class="number">0x48</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CK为固定参数 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> CK[<span class="number">32</span>] = &#123;</span><br><span class="line"><span class="number">0x00070e15</span>, <span class="number">0x1c232a31</span>, <span class="number">0x383f464d</span>, <span class="number">0x545b6269</span>,</span><br><span class="line"><span class="number">0x70777e85</span>, <span class="number">0x8c939aa1</span>, <span class="number">0xa8afb6bd</span>, <span class="number">0xc4cbd2d9</span>,</span><br><span class="line"><span class="number">0xe0e7eef5</span>, <span class="number">0xfc030a11</span>, <span class="number">0x181f262d</span>, <span class="number">0x343b4249</span>,</span><br><span class="line"><span class="number">0x50575e65</span>, <span class="number">0x6c737a81</span>, <span class="number">0x888f969d</span>, <span class="number">0xa4abb2b9</span>,</span><br><span class="line"><span class="number">0xc0c7ced5</span>, <span class="number">0xdce3eaf1</span>, <span class="number">0xf8ff060d</span>, <span class="number">0x141b2229</span>,</span><br><span class="line"><span class="number">0x30373e45</span>, <span class="number">0x4c535a61</span>, <span class="number">0x686f767d</span>, <span class="number">0x848b9299</span>,</span><br><span class="line"><span class="number">0xa0a7aeb5</span>, <span class="number">0xbcc3cad1</span>, <span class="number">0xd8dfe6ed</span>, <span class="number">0xf4fb0209</span>,</span><br><span class="line"><span class="number">0x10171e25</span>, <span class="number">0x2c333a41</span>, <span class="number">0x484f565d</span>, <span class="number">0x646b7279</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FK为系统参数 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> FK[<span class="number">4</span>] = &#123; <span class="number">0xa3b1bac6</span>L,<span class="number">0x56aa3350</span>L,<span class="number">0x677d9197</span>L,<span class="number">0xb27022dc</span>L &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左循环</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x,n)(((x)<span class="meta-string">&lt;&lt;n) | ((x)&gt;&gt;(32-n)))</span></span></span><br><span class="line"><span class="comment">//字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clip0(x)(( (x)&gt;&gt;24 ) &amp; 0xffL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clip1(x)(( ( (x)<span class="meta-string">&lt;&lt;8 )&gt;&gt;24) &amp; 0xffL)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clip2(x)(( ( (x)<span class="meta-string">&lt;&lt;16 )&gt;&gt;24) &amp; 0xffL)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clip3(x)(( ( (x)<span class="meta-string">&lt;&lt;24 )&gt;&gt;24) &amp; 0xffL)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性变换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L0(b)((b) ^ l(b,2) ^ l(b,10) ^ l(b,18) ^ l(b,24))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L1(b)((b) ^ l(b,13) ^ l(b,23))</span></span><br><span class="line"><span class="comment">//非线性变换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(b)( (Sbox[Clip0(b)] &lt;&lt; 24) | (Sbox[Clip1(b)] &lt;&lt; 16) | (Sbox[Clip2(b)] &lt;&lt; 8) | (Sbox[Clip3(b)]) )</span></span><br><span class="line"><span class="comment">//合成置换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T0(b)(L0(S(b)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T1(b)(L1(S(b)))</span></span><br></pre></td></tr></table></figure><h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a><font size = 3>初始化函数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_init</span><span class="params">(sm4 * sm)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">sm-&gt;x[i] = <span class="number">0L</span>;</span><br><span class="line">sm-&gt;k[i] = <span class="number">0L</span>;</span><br><span class="line">sm-&gt;rk[i] = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">sm-&gt;h[i] = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加工函数"><a href="#加工函数" class="headerlink" title="加工函数"></a><font size = 3>加工函数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加工函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_process</span><span class="params">(sm4 *sm,unsign32 bt,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = (num / <span class="number">4</span>);<span class="comment">//每个字4个字节，32位；16个字大小为512位</span></span><br><span class="line"></span><br><span class="line">sm-&gt;x[k] &lt;&lt;= <span class="number">8</span>;<span class="comment">//左移8位</span></span><br><span class="line">sm-&gt;x[k] |= (unsign32)(bt &amp; <span class="number">0xff</span>);<span class="comment">//保持补码的一致性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="密钥扩展函数"><a href="#密钥扩展函数" class="headerlink" title="密钥扩展函数"></a><font size = 3>密钥扩展函数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//密钥扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_extend</span><span class="params">(sm4 * sm)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">sm-&gt;k[<span class="number">0</span>] = sm-&gt;x[<span class="number">0</span>] ^ FK[<span class="number">0</span>];</span><br><span class="line">sm-&gt;k[<span class="number">1</span>] = sm-&gt;x[<span class="number">1</span>] ^ FK[<span class="number">1</span>];</span><br><span class="line">sm-&gt;k[<span class="number">2</span>] = sm-&gt;x[<span class="number">2</span>] ^ FK[<span class="number">2</span>];</span><br><span class="line">sm-&gt;k[<span class="number">3</span>] = sm-&gt;x[<span class="number">3</span>] ^ FK[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">sm-&gt;k[i + <span class="number">4</span>] = sm-&gt;k[i] ^ T1(sm-&gt;k[i + <span class="number">1</span>] ^ sm-&gt;k[i + <span class="number">2</span>] ^ sm-&gt;k[i + <span class="number">3</span>] ^ CK[i]);</span><br><span class="line">sm-&gt;rk[i] = sm-&gt;k[i + <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a><font size = 3>加密函数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加密函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_encrypt</span><span class="params">(sm4 * sm,unsign32 *Ciphertext)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">sm-&gt;x[i + <span class="number">4</span>] = sm-&gt;x[i] ^ T0(sm-&gt;x[i + <span class="number">1</span>] ^ sm-&gt;x[i + <span class="number">2</span>] ^ sm-&gt;x[i + <span class="number">3</span>] ^ sm-&gt;rk[i]);</span><br><span class="line">&#125;</span><br><span class="line">Ciphertext[<span class="number">0</span>] = sm-&gt;x[<span class="number">35</span>];</span><br><span class="line">Ciphertext[<span class="number">1</span>] = sm-&gt;x[<span class="number">34</span>];</span><br><span class="line">Ciphertext[<span class="number">2</span>] = sm-&gt;x[<span class="number">33</span>];</span><br><span class="line">Ciphertext[<span class="number">3</span>] = sm-&gt;x[<span class="number">32</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解密函数"><a href="#解密函数" class="headerlink" title="解密函数"></a><font size = 3>解密函数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解密函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_decrypt</span><span class="params">(sm4 * sm, unsign32 *Ciphertext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;<span class="comment">//解密结构与加密相同，只有轮密钥为倒序</span></span><br><span class="line">sm-&gt;x[i + <span class="number">4</span>] = sm-&gt;x[i] ^ T0(sm-&gt;x[i + <span class="number">1</span>] ^ sm-&gt;x[i + <span class="number">2</span>] ^ sm-&gt;x[i + <span class="number">3</span>] ^ sm-&gt;rk[<span class="number">31</span>-i]);</span><br><span class="line">&#125;</span><br><span class="line">Ciphertext[<span class="number">0</span>] = sm-&gt;x[<span class="number">35</span>];</span><br><span class="line">Ciphertext[<span class="number">1</span>] = sm-&gt;x[<span class="number">34</span>];</span><br><span class="line">Ciphertext[<span class="number">2</span>] = sm-&gt;x[<span class="number">33</span>];</span><br><span class="line">Ciphertext[<span class="number">3</span>] = sm-&gt;x[<span class="number">32</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口封装函数"><a href="#接口封装函数" class="headerlink" title="接口封装函数"></a><font size = 3>接口封装函数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口封装</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm4_hash</span><span class="params">(unsign32 *test, unsign32 *test1, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 当n为1时，进行加密；当n为0时，进行解密。 */</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">sm4 sm;</span><br><span class="line">sm4_init(&amp;sm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">sm4_process(&amp;sm, test[i], i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sm4_extend(&amp;sm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n) &#123;</span><br><span class="line">sm4_encrypt(&amp;sm, sm.h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//解密需获取加密明文的轮密钥</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">sm4_process(&amp;sm, test1[i], i);</span><br><span class="line">&#125;</span><br><span class="line">sm4_decrypt(&amp;sm, sm.h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">1</span>) &#123;</span><br><span class="line">test[i] = Clip0(sm.h[i / <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">2</span>) &#123;</span><br><span class="line">test[i] = Clip1(sm.h[i / <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">3</span>) &#123;</span><br><span class="line">test[i] = Clip2(sm.h[i / <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">test[i] = Clip3(sm.h[i / <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02x "</span>, test[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(C)实现SM3国密算法</title>
      <link href="/2020/03/09/%5BC%5D%E5%AE%9E%E7%8E%B0sm3%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/09/%5BC%5D%E5%AE%9E%E7%8E%B0sm3%E5%9B%BD%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于<strong>mircal</strong>库中的<strong>SHA-256</strong>算法改编而成。</p></blockquote><a id="more"></a><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>全称：“SM3密码杂凑算法”<em>(SM3 Cryptographic Hash Algorithm)</em>，其中sm是<strong>商用密码</strong>的拼音简称。</p><p> 以下是算法文字说明<br> 大致思想与SHA-256一致</p></li></ul><h2 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h2><p><img src="https://s2.ax1x.com/2020/03/09/89hnG8.jpg" alt="" title="说明1"></p><hr><p><img src="https://s2.ax1x.com/2020/03/09/89hZIP.jpg" alt="" title="说明2"></p><hr><p><img src="https://s2.ax1x.com/2020/03/09/89hmPf.jpg" alt="" title="说明3"></p><hr><p><img src="https://s2.ax1x.com/2020/03/09/89hVat.jpg" alt="" title="说明4"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font size = 3>定义</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义无符号整型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsign32 unsigned int</span></span><br><span class="line"><span class="comment">//定义sm3结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">unsign32 length[<span class="number">2</span>];<span class="comment">//保证消息长度满足条件：L &lt; 2^32</span></span><br><span class="line">unsign32 h[<span class="number">8</span>];   <span class="comment">//记录生成的杂凑值</span></span><br><span class="line">unsign32 w0[<span class="number">80</span>];</span><br><span class="line">unsign32 w1[<span class="number">80</span>];</span><br><span class="line">&#125; sm3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zero 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pad 0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T0 0x79cc4519L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T1 0x7a879d8aL</span></span><br><span class="line"><span class="comment">//定义初始值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> unsign32 InitNum[<span class="number">8</span>] = &#123;</span><br><span class="line"><span class="number">0x7380166f</span>L,<span class="number">0x4914b2b9</span>L,<span class="number">0x172442d7</span>L,<span class="number">0xda8a0600</span>L,</span><br><span class="line"><span class="number">0xa96f30bc</span>L,<span class="number">0x163138aa</span>L,<span class="number">0xe38dee4d</span>L,<span class="number">0xb0fb0e4e</span>L</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义布尔函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF0(X,Y,Z)  ((X)^(Y)^(Z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF1(X,Y,Z)((X&amp;Y)|(X&amp;Z)|(Y&amp;Z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GG0(X,Y,Z)((X)^(Y)^(Z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GG1(X,Y,Z)((X&amp;Y)|(~(X)&amp;Z))</span></span><br><span class="line"><span class="comment">//定义置换函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(X,n)(((X)<span class="meta-string">&lt;&lt;n) | ((X)&gt;&gt;(32-n)))</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P0(X)((X)^L(X,9)^L(X,17))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P1(X)((X)^L(X,15)^L(X,23))</span></span><br></pre></td></tr></table></figure><h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a><font size = 3>初始化函数</font></h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm3_init</span><span class="params">(sm3 *sm)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">80</span>; i++) &#123;</span><br><span class="line">sm-&gt;w0[i] = <span class="number">0L</span>;</span><br><span class="line">sm-&gt;w1[i] = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line">sm-&gt;length[<span class="number">0</span>] = sm-&gt;length[<span class="number">1</span>] = <span class="number">0L</span>;</span><br><span class="line">sm-&gt;h[<span class="number">0</span>] = InitNum[<span class="number">0</span>]; sm-&gt;h[<span class="number">1</span>] = InitNum[<span class="number">1</span>];</span><br><span class="line">sm-&gt;h[<span class="number">2</span>] = InitNum[<span class="number">2</span>]; sm-&gt;h[<span class="number">3</span>] = InitNum[<span class="number">3</span>];</span><br><span class="line">sm-&gt;h[<span class="number">4</span>] = InitNum[<span class="number">4</span>]; sm-&gt;h[<span class="number">5</span>] = InitNum[<span class="number">5</span>];</span><br><span class="line">sm-&gt;h[<span class="number">6</span>] = InitNum[<span class="number">6</span>]; sm-&gt;h[<span class="number">7</span>] = InitNum[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加工函数"><a href="#加工函数" class="headerlink" title="加工函数"></a><font size = 3>加工函数</font></h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//加工函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm3_process</span><span class="params">(sm3 *sm,<span class="keyword">int</span> bt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = (<span class="keyword">int</span>)((sm-&gt;length[<span class="number">0</span>] / <span class="number">32</span>) % <span class="number">16</span>);<span class="comment">//每个字4个字节，32位；16个字大小为512位</span></span><br><span class="line"></span><br><span class="line">sm-&gt;w0[k] &lt;&lt;= <span class="number">8</span>;<span class="comment">//左移8位</span></span><br><span class="line">sm-&gt;w0[k] |= (unsign32)(bt &amp; <span class="number">0xff</span>);<span class="comment">//保持补码的一致性</span></span><br><span class="line"></span><br><span class="line">sm-&gt;length[<span class="number">0</span>] += <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (sm-&gt;length[<span class="number">0</span>] == <span class="number">0L</span>) &#123;<span class="comment">//无符号整型溢出将进行舍弃最高位的操作</span></span><br><span class="line">sm-&gt;length[<span class="number">1</span>]++;  <span class="comment">//消息长度需小于2^64，所以2个字足够保证记录消息长度</span></span><br><span class="line">sm-&gt;length[<span class="number">0</span>] = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((sm-&gt;length[<span class="number">0</span>] % <span class="number">512</span>) == <span class="number">0</span>) &#123;<span class="comment">//若消息长度超过512，便直接对其前面16个字进行处理</span></span><br><span class="line">sm3_transform(sm); <span class="comment">//降低算法复杂度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a><font size = 3>转换函数</font></h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm3_transform</span><span class="params">(sm3 *sm)</span> </span>&#123;</span><br><span class="line">unsign32 A, B, C, D, E, F, G, H, SS1, SS2, TT1, TT2;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">16</span>; i &lt; <span class="number">68</span>; i++) &#123;</span><br><span class="line">sm-&gt;w0[i] = P1(sm-&gt;w0[i - <span class="number">16</span>] ^ sm-&gt;w0[i - <span class="number">9</span>] ^ (L(sm-&gt;w0[i - <span class="number">3</span>], <span class="number">15</span>))) ^ L(sm-&gt;w0[i - <span class="number">13</span>], <span class="number">7</span>) ^ sm-&gt;w0[i - <span class="number">6</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">sm-&gt;w1[i] = sm-&gt;w0[i] ^ sm-&gt;w0[i + <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A = sm-&gt;h[<span class="number">0</span>]; B = sm-&gt;h[<span class="number">1</span>]; C = sm-&gt;h[<span class="number">2</span>]; D = sm-&gt;h[<span class="number">3</span>];</span><br><span class="line">E = sm-&gt;h[<span class="number">4</span>]; F = sm-&gt;h[<span class="number">5</span>]; G = sm-&gt;h[<span class="number">6</span>]; H = sm-&gt;h[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">SS1 = (i&lt;=<span class="number">15</span>) ? L(L(A, <span class="number">12</span>) + E + L(T0, i), <span class="number">7</span>) : L(L(A, <span class="number">12</span>) + E + L(T1, i), <span class="number">7</span>);</span><br><span class="line">SS2 = (SS1) ^ L(A, <span class="number">12</span>);</span><br><span class="line">TT1 = (i&lt;=<span class="number">15</span>) ? FF0(A, B, C) + D + SS2 + sm-&gt;w1[i] : FF1(A, B, C) + D + SS2 + sm-&gt;w1[i];</span><br><span class="line">TT2 = (i&lt;=<span class="number">15</span>) ? GG0(E, F, G) + H + SS1 + sm-&gt;w0[i] : GG1(E, F, G) + H + SS1 + sm-&gt;w0[i];</span><br><span class="line">D = C;</span><br><span class="line">C = L(B, <span class="number">9</span>);</span><br><span class="line">B = A;</span><br><span class="line">A = TT1;</span><br><span class="line">H = G;</span><br><span class="line">G = L(F, <span class="number">19</span>);</span><br><span class="line">F = E;</span><br><span class="line">E = P0(TT2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sm-&gt;h[<span class="number">0</span>] ^= A; sm-&gt;h[<span class="number">1</span>] ^= B; sm-&gt;h[<span class="number">2</span>] ^= C; sm-&gt;h[<span class="number">3</span>] ^= D;</span><br><span class="line">sm-&gt;h[<span class="number">4</span>] ^= E; sm-&gt;h[<span class="number">5</span>] ^= F; sm-&gt;h[<span class="number">6</span>] ^= G; sm-&gt;h[<span class="number">7</span>] ^= H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成杂凑值函数"><a href="#生成杂凑值函数" class="headerlink" title="生成杂凑值函数"></a><font size = 3>生成杂凑值函数</font></h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//生成杂凑值函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm3_final</span><span class="params">(sm3 *sm,<span class="keyword">unsigned</span> <span class="keyword">char</span> h[<span class="number">32</span>])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">unsign32 len0 = sm-&gt;length[<span class="number">0</span>];</span><br><span class="line">unsign32 len1 = sm-&gt;length[<span class="number">1</span>];</span><br><span class="line">sm3_process(sm, pad);</span><br><span class="line"><span class="keyword">while</span> (sm-&gt;length[<span class="number">0</span>] % <span class="number">512</span> != <span class="number">448</span>) &#123;</span><br><span class="line">sm3_process(sm, zero);</span><br><span class="line">&#125;</span><br><span class="line">sm-&gt;w0[<span class="number">14</span>] = len1;</span><br><span class="line">sm-&gt;w0[<span class="number">15</span>] = len0;</span><br><span class="line">sm3_transform(sm);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">h[i] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((sm-&gt;h[i / <span class="number">4</span>] &gt;&gt; (<span class="number">8</span> * (<span class="number">3</span> - i % <span class="number">4</span>))) &amp; <span class="number">0xff</span>L);</span><br><span class="line">&#125;</span><br><span class="line">sm3_init(sm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口封装函数"><a href="#接口封装函数" class="headerlink" title="接口封装函数"></a><font size = 3>接口封装函数</font></h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口封装</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sm3_hash</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *test)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">sm3 sm;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> h[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">sm3_init(&amp;sm);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; test[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">sm3_process(&amp;sm, test[i]);</span><br><span class="line">&#125;</span><br><span class="line">sm3_final(&amp;sm, h);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)h[i]);</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体使用例子"><a href="#具体使用例子" class="headerlink" title="具体使用例子"></a><font size = 3>具体使用例子</font></h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> test[] = <span class="string">"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd"</span>;</span><br><span class="line">sm3_hash(test);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
